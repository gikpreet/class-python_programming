= Module 11: Understanding program efficiency part 1

== Today

* 복잡도 분류
* 각 분류의 특징 예제

== 프로그램의 효율성을 이해해야 하는 이유

* 특정 규모의 문제를 해결하는데 필요한 시간을 예측하기 위한 알고리즘 추론
* 알고리즘 설계의 선택과 결과 알고리즘의 시간 효율성 연관
** 특정 문제를 해결하는데 필요한 시간에 대한 제약

== ORDERS OF GROWTH: RECAP

목표:

* **입력이 매우 클 때** 프로그램의 효율성을 측정
* 입력 크기가 증가함에 따라 **프로그램의 실행 시간이 늘어나는 것**을 표현
* 향상의 **상한선(upper bound)**을 최대한 엄격하게 정함
* 정확할 필요는 없음(it's "order of", ot "exact")
* 런타임에서 **가장 큰 요소**를 살펴봄 (프로그램의 어떤 부분이 실행에 가장 오랜 시간을 소요하는가?)
* **따라서 일반적으로 최악의 경우 입력 크기의 함수로서 향상의 상한선을 정함**

== 복잡성 분류(Complexity class): RECAP

* O(1)은 일정한 실행 시간을 나타냄
* O(log n)은 로그 실행 시간을 나타냄
* O(n)은 선형 실행 시간을 나타냄
* O(n log n)은 로그 선형 실행 시간을 나타냄
* O(n^c^)는 다항식 실행 시간을 나타냄(c는 상수)
* O(c^n^)은 지수 실행 시간을 나타냅니다. (c는 입력 크기에 따라 거듭제곱되는 상수)

== Complexity classes ordered low to high

image:./images/image03.png[]

== 복잡성 증가

[cols="1,1,1,1,1" options=header]
|===
|class|n=10|=100|=1000|=1000000
|O(1) | 1 | 1 | 1| 1
|O(log n)| 1 | 2 | 3| 6
|O(n)| 10 | 100 | 1000 | 1000000
|O(n log n) | 10 | 200 |  3000| 6000000
|O(n^2^)| 100 | 10000| 1000000| 1000000000000
|O(2^n^) |1024| 1267650600228229
401496703205376|
10715086071862673
20948425049060001
81056140481170553
36074437503883703
51051124936122493
19837881569585812
75946729175531468
25187145285692314
04359845775746985
74803934567774824
23098542107460506
23711418779541821
53046474983581941
26739876755916554
39460770629145711
96477686542167660
42983165262438683
7205668069376| good luck!
|===

== Constant Complexity

