= Module 10: Understanding program efficiency part 1

== 오늘

* 알고리즘 성장 순서 측정
* Big "O" 표기법
* 클래스 복잡성

== 프로그램의 효율성을 이해

* 컴퓨터는 점점 더 빨리지므로, 프로그램의 효율의 중요성은 떨어지고 있을까?
** 그러나 데이터 세트는 매우 클 수 있다(예: 2014년 Google은 30,000,000,000,000페이지, 100,000,000GB에 해당. brute force 검색을 수행하는 데 얼마나 오랜 시간이 소요될까?)
** 따라서 단순한 솔루션은 수용 가능한 방식으로 크기가 확장되지 않을 수 있음
* 어떤 프로그램 옵션이 가장 효율적인지 어떻게 결정 할까?

* 프로그램의 **시간 및 공간 효율성**을 분리
* 시간 및 공간 효율성 사이의 절충안:
** 때로는 사전 계산 결과를 저장. 그런 다음 "조회"를 사용하여 검색(예: 피보나치 memoization)
** 여기에서는 시간 효율성에 중점을 둘 것

