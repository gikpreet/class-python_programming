= Module 10: Understanding program efficiency part 1

== 오늘

* 알고리즘 성장 순서 측정
* Big "O" 표기법
* 클래스 복잡성

== 프로그램의 효율성을 이해

* 컴퓨터는 점점 더 빨리지므로, 프로그램의 효율의 중요성은 떨어지고 있을까?
** 그러나 데이터 세트는 매우 클 수 있다(예: 2014년 Google은 30,000,000,000,000페이지, 100,000,000GB에 해당. brute force 검색을 수행하는 데 얼마나 오랜 시간이 소요될까?)
** 따라서 단순한 솔루션은 수용 가능한 방식으로 크기가 확장되지 않을 수 있음
* 어떤 프로그램 옵션이 가장 효율적인지 어떻게 결정 할까?

* 프로그램의 **시간 및 공간 효율성**을 분리
* 시간 및 공간 효율성 사이의 절충안:
** 때로는 사전 계산 결과를 저장. 그런 다음 "조회"를 사용하여 검색(예: 피보나치 memoization)
** 여기에서는 시간 효율성에 중점을 둘 것

== 프로그램의 효율성을 이해

계산 문제에 대한 솔루션의 효율성을 이해하는 데 어려움이 있음

* 프로그램은 **다양한 방법으로 구현**될 수 있음
* 몇 가지 **알고리즘**만 사용하여 문제를 해결할 수 있음
* 구현 선택과 좀 더 추상적인 알고리즘 선택을 분리해야 함

== 프로그램 효율성 연산(evaluate)

* **timer**로 측정
* 작업(operation)의 **count**
* **성장 순서**에 대한 추상적 개념 +
이것이 문제 해결에 있어 알고리즘 선택의 영향에 접근하는 가장 적절한 방법이며. 그리고 문제 해결에 있어서 본질적인 어려움을 측정하는 것

== Timning a program

* time module 사용
* import는 해당 클래스를 코드 파일로 가져오는 것을 의미

[source, python]
----
import time

def c_to_f(c):
    return c * 9 / 5 + 32

t0 = time.perf_counter()        # start clock
c_to_f(100000)                  # 함수 호출
t1 = time.perf_counter() - t0   # stop clock

print("t = ", t0, ":", t1, "s, ")
----

== Timing 프로그램은 일관성이 없음

* 목표: 다양한 알고리즘의 평가
* 실행 시간은 **알고리즘마다 다름** (만족)
* 실행 시간은 **구현마다 다름**    (만족되지 않음)
* 실행 시간은 **컴퓨터마다 다름**   (만족되지 않음)
* 작은 입력으로 실행 시간을 **예측할 수 없음**  (만족되지 않음)

* 시간은 입력마다 다르디만 입력과 시간간의 관계를 실제로 표현할 수는 없음

== Counting 동작

* 이 단계에는 일정한 시간이 걸린다고 가정
** 수학 연산
** 비교
** 할당
** 메모리에 있는 객체에 접근
* 그 후 입력 크기의 함수로 실행된 작업 수 계산

[source, python]
----
def c_to_f(c):
    return c * 9 / 5 * 32   # 3 ops

def mysum(x):
    total = 0   # 1 op
    for i in range(x + 1):  # loop x times, (x + 1) 에서 1 op
        total += 1          # 1 op    
    return total
----

== Counting 동작이 더 낫지만...

* 목표: 다양한 알고리즘의 평가
* 실행 시간은 **알고리즘마다 다름** (만족)
* 실행 시간은 **구현마다 다름**    (만족되지 않음)
* 실행 시간은 **컴퓨터마다 다름**   (만족)
* 작은 입력으로 실행 시간을 **예측할 수 없음**  (만족되지 않음)

* count는 입력마다 다르며 입력과 개수 사이의 관계를 알아낼 수 있음

== 더 나은 방법이 필요

* timing과 counting으로 **구현을 평가**함
* timing이 **기계를 평가**함

* **알고리즘(Algorithm)을 평가**해야 함
* **확장성(Scalability)**을 평가해야 함
* **입력 크기 측면에서 평가**해야 함

== 더 나은 방법이 필요

* 알고리즘에서 작업 계산에 대한 아이디어에 초점을 맞추지만 구현시 작은 변수에 대해서는 걱정하지 않음(예: 반복 단계를 실행하기 위해 3개 또는 4개의 기본 연산을 사용하는지의 여부)
* 문제의 크기가 임의로 커질 때 알고리즘이 어떻게 수행되는지에 중점을 두어야 함
* 이런 방식으로 측정된 계산을 완료하는데 필요한 시간을 문제에 대한 입력 크기와 연관하려는 경우
* 실제 단계 수는 시험의 세부 사항에 따라 달라질 수 있으므로 무엇을 측정할지 결정해야 함

== 함수를 평가하는데 사용할 입력을 선택해야 함

* 입력 크기 측면에서 효율성을 표현하려면 입력이 무엇인지 결정해야 함
* **정수**일 수 있음 +
`mysum(x)`
* **list의 길이**일 수 있음 +
`list_sum(L)`
* 함수에 여러 파라미터를 사용하는 시기를 결정 +
`search_for_elmt(L, e)`