= Module 10: Understanding program efficiency part 1

== 오늘

* 알고리즘 성장 순서 측정
* Big "O" 표기법
* 클래스 복잡성

== 프로그램의 효율성을 이해

* 컴퓨터는 점점 더 빨리지므로, 프로그램의 효율의 중요성은 떨어지고 있을까?
** 그러나 데이터 세트는 매우 클 수 있다(예: 2014년 Google은 30,000,000,000,000페이지, 100,000,000GB에 해당. brute force 검색을 수행하는 데 얼마나 오랜 시간이 소요될까?)
** 따라서 단순한 솔루션은 수용 가능한 방식으로 크기가 확장되지 않을 수 있음
* 어떤 프로그램 옵션이 가장 효율적인지 어떻게 결정 할까?

* 프로그램의 **시간 및 공간 효율성**을 분리
* 시간 및 공간 효율성 사이의 절충안:
** 때로는 사전 계산 결과를 저장. 그런 다음 "조회"를 사용하여 검색(예: 피보나치 memoization)
** 여기에서는 시간 효율성에 중점을 둘 것

== 프로그램의 효율성을 이해

계산 문제에 대한 솔루션의 효율성을 이해하는 데 어려움이 있음

* 프로그램은 **다양한 방법으로 구현**될 수 있음
* 몇 가지 **알고리즘**만 사용하여 문제를 해결할 수 있음
* 구현 선택과 좀 더 추상적인 알고리즘 선택을 분리해야 함

== 프로그램 효율성 연산(evaluate)

* **timer**로 측정
* 작업(operation)의 **count**
* **성장 순서**에 대한 추상적 개념 +
이것이 문제 해결에 있어 알고리즘 선택의 영향에 접근하는 가장 적절한 방법이며. 그리고 문제 해결에 있어서 본질적인 어려움을 측정하는 것

== Timning a program

* time module 사용
* import는 해당 클래스를 코드 파일로 가져오는 것을 의미

[source, python]
----
import time

def c_to_f(c):
    return c * 9 / 5 + 32

t0 = time.perf_counter()        # start clock
c_to_f(100000)                  # 함수 호출
t1 = time.perf_counter() - t0   # stop clock

print("t = ", t0, ":", t1, "s, ")
----