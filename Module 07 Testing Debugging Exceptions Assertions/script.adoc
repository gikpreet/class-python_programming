좋아요, 여러분. 좋은 오후에요. 시작하자. 그래서 오늘 강의에서는 테스트, 디버깅, 예외 및 어설션에 대해 다루겠습니다. 그럼 시작하기 전에 잠시 현실 생활로 돌아가기 위해 비유부터 시작하겠습니다.

그래서 전에 수프를 만들어 본 적이 있어요. 아마도 당신은 전에 수프를 만들어 본 적이 있을 것입니다. 여기 이 큰 냄비에 수프를 만들고 있다고 가정해 보겠습니다. 그리고 벌레가 천장에서 수프 속으로 계속 떨어지는 것으로 나타났습니다. 괜찮은. 청중에게 빠른 질문을 합니다. 이 문제가 발생하면 어떻게 합니까?

청중: [목소리 끼어들기]

교수: 좋습니다. 손 들어. 한 번에 하나씩. 누구든지 어떤 생각을 가지고 있습니까? 응.

청중: 먹어보세요.

교수: 먹어보세요. 먹고 싶으면 어쨌든 OK. 괜찮은. 여기서는 컴퓨터 프로그래밍에 비유해 보겠습니다. 버그가 있는 프로그램이 있으면 어떻게 할지 모르겠습니다. 그냥 고객에게 공개하면 고객이 불평할 것 같지만. 좋아요. 또 뭐야? 응.

청중: [들리지 않음] 수프를 덮으시겠습니까?

교수: 수프를 덮어주세요. 좋은 제안이네요. 응. 그래야 국물을 덮을 수 있으니 뚜껑을 덮어주세요. 때로는 뚜껑을 열어서 뚜껑을 열어서 제대로 되었는지 확인해야 할 때도 있습니다. 맛을 보려면 뭔가를 추가하세요. 그래서 그 사이에 벌레가 끼어들 수도 있습니다. 하지만 수프를 덮는 것이 좋은 생각입니다. 또 뭐야? 응.

청중: 디버깅해보세요.

교수: 디버깅해 보세요. 그 대답에 대한 뭔가가 있었으면 좋겠어요. 괜찮은. 좋은 답변이네요. 응.

청중: 집에 있는 모든 음식을 꺼내서 벌레가 먹을 것이 없도록 하세요.

교수: 그러니 집에 있는 음식을 모두 꺼내서 벌레가 먹을 것이 없도록 하세요. 이는 집 전체를 대대적으로 청소하는 것과 같은 청소와 같습니다. 그거 좋은거야, 그거 좋은거야. 그것은 버그의 근원을 제거하는 것과 같습니다. 그렇죠? 또 뭐야? 응, 존.

청중: 그것이 고단백이라고 결정하고 그것을 특징으로 선언하십시오.

교수: 단백질 함량이 높다고 결정하고 특징으로 선언하세요. 아마 많은 사람들이 그렇게 할 겁니다. 그렇죠? 괜찮은. 시원한. 그래서 나는 컴퓨터 디버깅이 수프에서 버그를 제거하는 것만큼 재미있기를 바랍니다. 그래서 우리는 무엇을 결정 했습니까? 그럼 수프에 벌레가 있는지 확인해 볼 수 있겠네요. 뚜껑을 닫아두세요. 좋은 제안이었습니다. 그리고 누군가가 제안한 주방 청소도요. 부엌을 청소하는 것은 음식을 모두 버리는 것과 같습니다. 대걸레를 들고 바닥을 청소할 텐데, 네, 그것도 효과가 있어요. 따라서 우리는 컴퓨터 프로그래밍과 이러한 비유에 대해 몇 가지 유사점을 그릴 수 있습니다.

그래서 수프를 확인하는 것은 실제로 테스트와 동일합니다. 그렇죠? 벌레가 들어 있다고 생각되는 수프가 있습니다. 테스트해보세요. 버그가 없는지 확인하세요. 계속하세요. 뚜껑을 닫은 상태로 유지합니다. 일종의 방어 프로그래밍 아이디어입니다. 그러니 애초에 버그가 발생하지 않도록 주의하세요.

때로는 수프가 맛이 좋은지 확인하기 위해 뚜껑을 열어야 할 때도 있습니다. 따라서 이는 방어 프로그래밍과 동일합니다. 그러니 애초에 버그가 없도록 노력하세요. 하지만 어쨌든 버그가 나타날 수도 있습니다. 주방을 청소하면 애초에 벌레의 원인을 제거하는 것입니다. 실제로 프로그래밍에서는 이것이 매우 어렵습니다. 하지만 여전히 시도해 볼 수 있습니다. 좋아요.

그럼 지금까지 60001,600에서 프로그래밍에 대해 조금 이야기해 보겠습니다. 따라서 여러분은 실제로 프로그램을 작성하고 약간의 디버깅을 하고 프로그램을 실행하면 완벽할 것이라고 기대합니다.

오른쪽? 방금 해냈어요. 하지만 실제로는 이렇게 복잡한 코드를 작성하고 실행하면 충돌이 발생합니다. 오른쪽? 그것은 나에게 여러 번 일어났습니다. 그것은 당신에게 여러 번 일어났습니다. 그것이 현실입니다. 좋아요. 그래서 오늘 강의에서는 몇 가지 팁과 요령, 디버깅에 대해 설명하고 프로그램을 작성할 때 여기 있는 어린 소녀처럼 되지 않도록 삶을 더 쉽게 만드는 방법에 대해 설명합니다. 믿을 수 없을 정도로 실망했습니다. 괜찮은.

따라서 모든 것의 핵심은 방어적인 프로그래밍 태도에서 시작되는 것입니다. 좋아요. 그리고 이것은 우리가 시작했을 때, 즉 함수에 대한 강의를 할 때 이야기했던 분해와 추상화의 아이디어로 돌아옵니다. 오른쪽? 그러니 코드를 모듈화하는 두 가지 작업부터 시작해 보세요. 그렇죠? 서로 다른 블록에 코드를 작성하고 각각의 서로 다른 블록을 문서화하면 나중에 코드에서 무슨 일이 일어나고 있는지 더 쉽게 이해할 수 있고 훨씬 쉽게 테스트하고 디버그할 수 있습니다.

테스트와 디버깅에 관해 말하자면, 모듈식 프로그램을 작성하고 나면 여전히 테스트해야 합니다. 그리고 테스트 과정은 실제로 입력을 도출하는 것입니다. 기대하는 결과가 무엇인지 파악합니다. 그런 다음 프로그램을 실행하십시오. 프로그램이 제공하는 출력이 예상한 것과 일치합니까? 그렇다면, 끝났습니다. 하지만 그렇지 않은 경우에는 이 디버깅 단계로 이동해야 합니다. 그리고 디버깅 단계가 가장 어려운 부분입니다. 그리고 그것은 실제로 왜 프로그램이 충돌했는지, 또는 왜 프로그램이 기대했던 답변을 제공하지 않았는지 알아내는 것입니다.

따라서 앞서 언급했듯이 가장 중요한 것은 방어적인 프로그래밍을 수행하는 것이며 이를 위해서는 쉽게 테스트하고 디버깅할 수 있도록 설정하는 것이 좋습니다. 이는 여러분이 작성하는 코드가 모듈식인지 확인하는 것입니다. 그러니 최대한 많은 함수를 작성하세요. 기능이 무엇인지 문서화하십시오. 제약 조건을 문서화하십시오. 그리고 나중에 디버깅해야 할 때 생활이 조금 더 쉬워질 것입니다.

언제 테스트를 시작하시겠습니까? 먼저 프로그램이 실행되는지 확인해야 합니다. 따라서 Python이 쉽게 찾아낼 수 있는 구문 오류와 정적 의미 오류를 제거하세요. 코드 조각이 실행되는 것을 확인한 후에는 몇 가지 테스트 사례를 제시해야 합니다. 따라서 이것은 프로그램에서 기대하는 작업에 대한 입력 및 출력 쌍입니다.

테스트 사례와 실행되는 코드 조각이 있으면 테스트를 시작할 수 있습니다. 따라서 수행할 수 있는 테스트에는 세 가지 일반적인 클래스가 있습니다. 첫 번째는 단위 테스트라고 합니다. 그리고 함수를 작성한 경우 단위 테스트는 예를 들어 각 함수가 사양에 따라 실행되는지 확인하는 것입니다. 그래서 이 작업을 여러 번 수행합니다. 각 기능을 테스트하면서 버그를 발견할 수도 있습니다. 이 시점에서 회귀 테스트를 수행합니다. 해당 버그를 발견한 테스트 케이스를 생각해 보세요. 그리고 버그를 수정할 때 이미 실행된 코드 조각에 새로운 버그가 다시 발생하지 않도록 코드의 다양한 부분을 모두 다시 실행하세요.

So you do this a bunch of times. You do a little bit of unit testing, a little bit of regression testing, and keep doing that. At some point, you're ready to do integration testing. Which means, test your program as a whole. Does the overall program work? So this is the part where you take all of the individual pieces, put them together. And integration testing tests to make sure that the interactions between all of the different pieces works as expected. If it does, great, you're done. But if it doesn't, then you'll have to go back to unit testing, and regression testing, and so on. So it's really a cycle of testing.

그렇다면 테스트 방법에는 어떤 것들이 있나요? 첫 번째는 아마도 숫자를 포함하는 프로그램에서 가장 일반적일 것입니다. 숫자에 대한 자연스러운 경계를 알아내는 것입니다. 프로그램에서는 죄송합니다. 예를 들어, is_bigger 함수가 있고 x가 y보다 큰지 비교하면 사양에 따라 자연적인 경계는 x가 y보다 작고, x가 y보다 크고, x가 y와 같다는 것입니다. 보다 작거나 같거나 크거나 같거나 등을 입력할 수도 있습니다. 그래서 그것은 문제에 대한 일종의 직관입니다. 자연적인 분할이 없는 몇 가지 문제가 있을 수 있습니다. 어떤 경우에는 무작위 테스트를 수행할 수 있으며 무작위 테스트를 많이 수행할수록 프로그램이 정확할 가능성이 커집니다. 그러나 실제로 테스트를 수행하는 두 가지 더 엄격한 방법이 있습니다.

블랙박스 테스트에서는 기능에 대한 사양이 있다고 가정합니다. 이것이 바로 독스트링입니다. 여러분이 보고 있는 것은 문서화 문자열과 이를 기반으로 몇 가지 테스트 사례를 제시하는 것뿐입니다. 유리 상자 테스트에서는 코드 자체가 있고 코드를 통해 가능한 모든 경로에 도달하는 몇 가지 테스트 사례를 생각해내려고 합니다.

괜찮은. 블랙박스 테스트의 예를 살펴보겠습니다. 나는 이 엡실론이 제공하는 충분히 가까운 값에 대한 x의 제곱근을 찾고 있습니다. 그리고 여기서 아이디어는 실제로 이 기능이 어떻게 구현되는지 알려주지 않는다는 점입니다. 아이디어는 사양을 기반으로 테스트 사례를 파악하는 것입니다. 그리고 블랙박스 테스트의 가장 큰 장점은 이 기능을 구현하는 사람이 원하는 대로 구현할 수 있다는 것입니다. 근사 방법을 사용할 수도 있고 이분법을 사용할 수도 있지만 상관없습니다. 이 기능에 대해 생각해낸 테스트 사례는 정확히 동일할 것입니다. 오른쪽? 구현이 무엇이든 상관 없습니다.

이 특정 기능에 대한 샘플 세트는 다음과 같습니다. 경계를 확인하고, 완전제곱수를 확인하고, 1보다 작은 숫자를 확인하고, 무리수를 확인한 다음 극단적인 테스트를 수행합니다. 따라서 엡실론이 정말 크거나 엡실론이 정말 작거나, x가 정말 크거나 x가 정말 작을 때, 그리고 이들의 가능한 모든 조합이 가능합니다. 따라서 블랙박스 테스트에서 중요한 점은 사양만을 기반으로 테스트 케이스를 작성한다는 것입니다.

유리 상자 테스트에서는 코드 자체를 사용하여 테스트 사례를 안내합니다. 따라서 코드 조각이 있고 코드를 통해 가능한 모든 단일 경로의 가능한 모든 단일 입력 조합을 통과하는 테스트 사례를 생각해 낸 경우 해당 테스트 세트를 경로 완료라고 합니다. 예를 들어 루프가 발생할 때 문제가 발생합니다. 루프를 통해 가능한 모든 경로는 루프를 전혀 통과하지 않고 한 번 통과하고 두 번 통과하고 세 번, 네 번, 다섯 번 통과하는 코드일 수 있습니다. 오른쪽? 그것은 매우 큰 시험이 될 수 있습니다.

대신 루프 등을 다룰 때 실제로 몇 가지 지침이 있습니다. 따라서 분기의 경우 유리 상자 테스트를 수행할 때 조건의 모든 부분을 실행하는 것이 중요합니다. 따라서 조건문의 각 부분을 통과하는 테스트 케이스가 있는지 확인하십시오. for 루프의 경우 루프가 전혀 입력되지 않고, 루프가 한 번 입력되고, 루프가 몇 번 이상 입력되는 테스트 케이스가 있는지 확인하십시오.

For while 루프는 for 루프와 비슷하지만 while 루프에서 벗어날 수 있는 가능한 모든 방법을 포괄하는 테스트 사례가 있는지 확인해야 합니다. 따라서 while 루프 조건이 거짓이 되거나 while 루프 내부에 중단이 있는 경우 등이 발생합니다.

따라서 이 예에서는 x의 절대값이 있습니다. 이것은 사양이며 누군가가 이 기능을 수행하기로 결정한 구현입니다. 따라서 경로 완료 테스트 세트는 이러한 각 분기를 통과하는 테스트를 원한다는 것을 의미합니다. 그래서 x가 -1보다 작다면, 음, -2는 -1보다 작습니다. 그러면 좋습니다. 그렇지 않으면 마이너스 1보다 큰 숫자를 선택한다는 의미입니다. 따라서 2입니다. 따라서 2와 마이너스 2는 경로 완료입니다. 항복 경로 완료-- 경로 완료 테스트 스위트를 생성합니다.

그러나 이 코드를 통해 가능한 모든 경로를 탐색했지만 실제로는 테스트 사례를 놓쳤습니다. 마이너스 1. 따라서 이 코드는 마이너스 1을 마이너스 1을 반환하는 것으로 잘못 분류합니다. 이는 잘못된 것입니다. 따라서 유리 상자 테스트의 경우 코드를 통해 가능한 모든 경로를 통과하는지 확인하는 것 외에도 경계 조건에 도달하는지 확인해야 합니다. 따라서 이 경우 분기의 ​​경우 마이너스 1이 경계 조건입니다.

따라서 테스트 스위트를 만들고 프로그램을 테스트했는데 버그를 발견할 가능성이 높습니다. 지금 무엇을 하시나요?

괜찮은. 약간의 역사로의 빠른 우회. 디버깅의 역사. 그래서 1947년에 이 컴퓨터가 만들어졌습니다. 그리고 그것은 당시로서는 매우 인상적인 컴퓨터였습니다. 0.1초 만에 추가 같은 작업을 수행할 수 있습니다. 0.7초 만에 곱셈 같은 거요. 그리고 5초 안에 어떤 것에 대한 로그를 찍으세요. 그래서 아마도 인간보다 더 빠를 것입니다. 하지만 오늘날의 기준으로는 꽤 느립니다. 그리고 엔지니어 그룹은 삼각함수를 찾는 프로그램을 실행하는 작업을 하고 있었습니다. 그 중에는 최초의 여성 과학자 중 한 명인 그레이스 호퍼(Grace Hopper)도 있습니다.

그리고 그들은 그들의 프로그램이 제대로 작동하지 않는다는 것을 발견했습니다. 그래서 그들은 컴퓨터에 있는 모든 패널과 모든 릴레이를 살펴보고 패널 F 릴레이 70에서 프로그램을 분리하여 이 나방을 발견했습니다. 그냥 거기 앉아 있어요. 아마 감전사해서 죽은 것 같아요. 그런데 계산을 방해하는 것은 나방이었다. 그리고 여러분이 이 글을 읽을 수 있을지 모르겠지만, 이 부분은 바로 여기 있습니다. 그들은 로그북에 최초의 실제 버그 발견 사례를 기록했습니다. 정말 귀여운 것 같아요. 그래서 그들은 말 그대로 이 컴퓨터에서 디버깅을 하고 있었습니다. 오른쪽. 괜찮은.

따라서 그런 종류의 디버깅을 수행하지 않을 것입니다. 당신은 당신의 프로그램에서 가상의 디버깅을 하게 될 것입니다. 다시 말하지만 그다지 재미는 없습니다. 하지만 여전히 해야 합니다. 따라서 지금까지 문제 세트에서 알 수 있듯이 디버깅에는 약간의 학습 곡선이 있습니다. 그리고 분명히 여러분의 목표는 버그 없는 프로그램을 만드는 것이고, 이를 달성하려면 디버깅을 해야 합니다.

여러분 중 일부가 사용하고 있는 몇 가지 도구가 있습니다. Anaconda에는 몇 가지 도구가 내장되어 있거나 디버깅을 위해 사용한 ID가 있습니다. 저는 여러분 중 일부가 Python 교사를 사용해 왔다는 것을 알고 있습니다. 정말 대단합니다. print 문도 좋은 디버깅 도구가 될 수 있습니다. 그러나 무엇보다도, 프로그램을 디버깅할 때 체계적으로 하는 것이 정말 중요합니다.

저는 print 문과 이를 디버깅에 어떻게 사용할 수 있는지에 대해 조금 이야기하고 싶습니다. 왜냐하면 제 생각에는... Python 교사님, 인터넷이 없으면 사용하지 못할 수도 있습니다. 디버거 사용법을 모른다면 배울 필요가 없습니다. 그러나 인쇄문을 사용하면 항상 그 내용을 갖게 되며 언제든지 프로그램에 넣을 수 있습니다. 그리고 그것은 가설을 테스트하는 정말 좋은 방법입니다.

따라서 print 문을 넣기에 좋은 곳은 함수 내부입니다. 예를 들어 내부 루프에서는 루프 매개변수가 무엇인지, 루프 값이 무엇인지, 어떤 함수가 무엇인지, 어떤 함수가 어떤 값을 반환하는지 등을 알 수 있습니다. 따라서 값이 전달되고 있는지 확인할 수 있습니다. 즉, 코드 부분 간에 올바른 값이 전달되고 있습니다. 디버깅할 때 이분법을 사용할 수 있다는 점을 언급하겠습니다. 흥미롭습니다.

따라서 print 문을 사용하는 경우 코드에서 대략 중간 지점을 찾으세요. 어떤 값을 인쇄할지 인쇄하세요. 관련 값을 인쇄하세요. 가능한 모든 것 - 코드의 해당 지점에서 일부 값을 인쇄하십시오. 모든 것이 코드의 해당 지점에서 예상한 대로라면 괜찮습니다. 이는 지금까지의 코드에 버그가 없다는 의미입니다. 그 말은... 하지만 그건 당신이 괜찮다는 뜻이에요. 이는 지금까지의 코드에 버그가 없다는 의미입니다. 그건... 하지만 그건 그 너머의 코드에 버그가 있다는 뜻이죠. 그렇죠?

따라서 코드 중간에 print 문을 넣었고 그것이 좋은 결과를 냈다고 생각하므로 코드의 3/4 지점에 print 문을 넣으세요. 그리고 그 시점에서 값이 예상한 대로인지 확인합니다. 만약 그렇다면 좋습니다. 그런 다음 print 문을 더 아래에 넣으십시오. 따라서 이런 방식으로 이분법을 사용하여 선이나 선 세트 또는 나쁜 결과를 제공하는 함수를 찾아낼 수 있습니다.

따라서 일반적인 디버깅 단계는 프로그램 코드를 연구하는 것입니다. 실제로 테스트의 일부이기 때문에 무엇이 잘못되었는지 묻지 마십시오. 따라서 테스트 사례에서는 무엇이 잘못되었는지 알아냈을 것입니다. 디버깅 프로세스는 결과가 어떻게 발생했는지 파악하는 것입니다. 그리고 프로그래밍은... 프로그래밍과 디버깅은 일종의 과학이므로 과학적인 방법도 사용할 수 있습니다. 따라서 모든 데이터를 살펴보십시오. 이것이 테스트 사례입니다. 가설을 세워보세요. 예를 들어, 아, 어쩌면 목록에서 0 대신 1부터 색인을 생성하고 있을 수도 있습니다. 반복할 수 있는 실험을 생각해 보세요. 그런 다음 간단한 테스트 사례를 선택하여 가설을 테스트할 수 있습니다.

따라서 디버깅하는 동안 오류 메시지가 표시됩니다. 그리고 이러한 오류 메시지는 실제로 파악하기가 매우 쉽습니다. 그리고 코드에서 수정하기가 정말 쉽습니다. 예를 들어 목록의 한계를 넘어서는 항목에 액세스하면 색인 오류가 발생합니다. 이 경우 목록을 정수로 변환하려고 하면 유형 오류가 발생합니다. 이전에 생성하지 않은 변수에 액세스하면 이름 오류가 발생합니다. 등등. 그리고 구문 오류는 괄호를 잊어버리거나 콜론을 잊어버린 경우와 같은 것입니다.

따라서 오류 메시지는 정말 쉽게 알아볼 수 있습니다. Python 인터프리터가 이를 알려준다면 정확한 줄을 찾아낼 수 있습니다. 논리 오류는 실제로 어려운 부분입니다. 그리고 논리 오류는 가장 많은 시간을 소비하게 될 오류입니다. 이를 위해서는 항상 휴식을 취하는 것이 좋습니다. 낮잠 자고, 가서 먹어. 무엇. 때로는 처음부터 다시 시작해야 할 수도 있습니다. 따라서 보유하고 있는 코드 전반에 걸쳐 종이 한 장을 들고 앉아서 문제를 해결하는 방법을 알아내도록 노력하십시오.

그리고 러버 덕키(Rubber Ducky)라는 용어를 찾아보면, 러버 덕키 디버깅에 관해 많은 사람들이 관심을 보였습니다. 이는 Wikipedia의 실제 용어입니다. 프로그래머가 고무 오리에게 코드를 설명하는 순간입니다. 왼쪽에 있는 제가 고무 오리에게 코드를 설명하고 있습니다. 넌 항상... 가서 하나 사야 해. 또는 다른 사람, 가급적이면 아무것도 이해하지 못하는 사람에게 코드를 작성하세요. 그렇게 하면 모든 것을 정말, 정말 자세히 설명해야 하기 때문입니다. 그리고 그렇게 하면서 당신의 문제를 파악하게 될 것입니다. 그리고 나는 이 두 경우 모두에서 내 문제를 알아냈습니다. 그러니 그냥 기본으로 돌아가세요.

디버깅 및 테스트 시 해야 할 일과 하지 말아야 할 일에 대한 간략한 요약입니다. 따라서 전체 프로그램을 작성하고, 전체 프로그램을 테스트하고, 전체 프로그램을 디버그하지 마십시오. 나는 이것이 정말 하고 싶은 유혹이라는 것을 알고 있으며 항상 그렇게 합니다. 하지만 그러지 마세요. 많은 버그가 발생하게 되고 어떤 버그가 다른 버그에 영향을 미치는지 분리하기가 어렵기 때문입니다. 그리고 그것은 당신이 필요로 하는 것보다 훨씬 더 많은 스트레스로 이어질 것입니다. 대신 단위 테스트를 수행하십시오. 따라서 하나의 함수를 작성하고, 함수를 테스트하고, 함수를 디버깅하고, 작동하는지 확인하고, 다른 함수를 작성하는 등의 작업을 계속하세요. 약간의 회귀 테스트, 약간의 단위 테스트, 약간의 통합 테스트를 수행하면 프로그램을 작성하는 훨씬 더 체계적인 방법이 됩니다. 그리고 디버깅 시간이 엄청나게 단축됩니다.

코드를 변경하고 문제 세트를 수행하면서 필연적으로 코드를 변경하게 될 경우 코드를 백업하는 것을 잊지 마세요. 따라서 거의 작동하는 버전이 있다면 단순히 수정하지 말고 복사본을 저장하세요. [들리지 않음] 컴퓨터에 테라바이트급의 메모리가 있으므로 간단히 복사해 두는 것도 문제가 되지 않습니다. 해당 사본에 무엇이 효과가 있었고 무엇이 효과가 없었는지 문서화하십시오. 그런 다음 또 다른 복사본을 만든 다음 코드를 수정할 수 있습니다.

이것은 테스트와 디버깅에 대한 높은 수준의 소개입니다. 수업의 나머지 부분은 오류 메시지 또는 프로그램에서 받게 될 오류에 대해 설명합니다. 따라서 함수를 실행하거나 프로그램을 실행하면 어느 시점에서 프로그램 실행이 중지됩니다. 예상치 못한 상황으로 인해 오류가 발생했을 수도 있습니다. 그리고 그런 일이 발생하면 예외가 발생합니다. 따라서 오류를 예외라고 합니다. 그리고 그것은 예상했던 것의 예외였기 때문에 예외라고 불립니다. 프로그램이 기대했던 것.

따라서 이전 슬라이드에서 언급한 이러한 모든 오류는 실제로 예외의 예입니다. 그리고 실제로는 이 과정과 60002에서 계속해서 볼 수 있는 다른 유형의 예외도 많이 있습니다.

그렇다면 이러한 예외를 어떻게 처리해야 할까요? Python에서는 실제로 예외 처리기를 가질 수 있습니다. 따라서 코드 조각으로 인해 오류가 발생할 수 있다는 것을 알고 있다면. 예를 들어, 여기서는 사용자의 입력을 다루고 있습니다. 그리고 사용자는 정말 예측할 수 없습니다. 전화번호를 알려달라고 하면 이름을 알려줄 수도 있습니다. 그것에 대해 당신이 할 수 있는 일은 아무것도 없습니다. 아니면 있습니까? 네, 그렇습니다. 따라서 프로그램에서 실제로 문제가 있을 수 있다고 생각되는 코드 줄, 오류 예외를 발생시킬 수 있는 코드 줄을 이 try 블록에 넣을 수 있습니다. 따라서 콜론을 시도해 보라고 말하고 오류가 발생할 수 있다고 생각되는 코드 줄을 입력합니다.

이러한 코드 줄 중 어느 것도 실제로 오류를 생성하지 않는다면 좋습니다. 파이썬은 다른 일을 하지 않습니다. 마치 정규 프로그램의 일부인 것처럼 그들을 단지 일부로 취급합니다. 그러나 오류가 발생하면(예를 들어 누군가 숫자를 입력하지 않고 이름을 입력하는 경우) 오류, 특히 값 오류가 발생합니다. 그리고 그 시점에서 Python은 accept 문이 있습니까?라고 말할 것입니다. 그렇다면 이 Except 문이 오류를 처리할 것입니다.

그러면 오류가 발생했지만 처리 방법을 알고 있습니다. 이 메시지를 사용자에게 인쇄하겠습니다. 따라서 코드를 살펴보면 슬라이드에 있는 코드와 동일하며 주변에 블록을 두는 것 외에는 시도할 방법이 없습니다. 따라서 실행하고 3, 4라고 말하면 잘 실행될 것입니다. 하지만 실행하고 [들리지 않음] a라고 말하면 값 오류가 발생합니다.

이제 try-- 블록을 제외한 try를 사용하여 동일한 코드 조각을 실행하면 됩니다. 나는 그것을 실행합니다. 정규 숫자를 주면 괜찮습니다. 그러나 제가 건방진 사용자이고 3이라고 말하면 자동으로 이전 버전의 프로그램에서 값 오류가 발생했을 것입니다. 그러나 이 버전의 프로그램에서는 프로그래머가 예외를 처리하거나 예외를 포착하여 더 보기 좋은 메시지를 인쇄했습니다. 따라서 사용자 입력의 버그는 여기 있는 이 모든 것보다 더 좋습니다. 읽기가 훨씬 쉽습니다.

따라서 문제가 있는 코드 줄은 try 블록에 넣은 다음 이 블록에서 발생할 수 있는 모든 오류를 처리할 수 있습니다. 이 제외 블록은 발생하는 모든 오류를 포착합니다. 그리고 실제로 좀 더 구체적으로 접근하여 특정 유형의 오류를 포착할 수 있습니다. 이 경우 값 오류가 발생하면(예를 들어 사용자가 정수 대신 문자열을 입력하는 경우) 이렇게 하면 이 메시지가 인쇄됩니다. 사용자가 b로 나누기를 수행하는 것과 같이 B에 숫자를 입력하면 0 나누기 오류가 발생합니다. 이 경우 우리는 여기서 다른 오류인 0 나누기 오류를 잡아서 0으로 나눌 수 없다는 다른 메시지를 인쇄하겠습니다.

그래서 각각-- 따라서 이러한 서로 다른 제외 블록을 예외를 제외하고 일종의 if else if 문으로 생각할 수 있습니다. 그래서 우리는 이것을 시도해 볼 것입니다. 하지만 값 오류가 있으면 이렇게 하세요. 그렇지 않고 나누기 오류가 있으면 이렇게 합니다. 그렇지 않으면 이렇게 하세요. 따라서 이 마지막 예외는 실제로 발생하는 다른 오류에 대한 것입니다. 따라서 값 오류나 나눗셈 오류가 아닌 경우 인쇄하면 뭔가 매우 잘못되었습니다. 저는 생성하려고 시도조차 할 수 없었습니다. 프로그램이 그 두 가지 외에 다른 오류를 발생시키도록 시도조차 할 수 없었습니다.

따라서 블록을 제외하고 try를 사용하는 경우가 많습니다. 그러나 예외에 추가할 수 있는 다른 블록이 있습니다. 그리고 이것들은 거의 사용되지 않지만 어쨌든 그것에 대해 이야기하겠습니다. 따라서 else 블록을 가질 수 있습니다. 그리고 try 블록의 코드가 오류 없이 완료되면 else 블록이 실행됩니다. 그리고 항상 실행되는 finally 블록을 가질 수도 있습니다. try 블록의 코드가 오류 없이 종료된 경우, 예외를 발생한 경우, 다른 종류의 예외를 발생한 경우, else를 거친 경우, 이러한 경우에 finally 블록에 있는 모든 내용은 항상 가져옵니다. 실행. 그리고 일반적으로 코드를 정리하는 데 사용됩니다. 인쇄하고 싶은 경우, 프로그램이 종료된 경우, 파일을 닫고 싶은 경우 등이 있습니다.

그래서. 오류가 발생했습니다. 우리는 그들을 잡았습니다. 오류로 인해 또 무엇을 할 수 있습니까? 예외가 있습니다. 다른 세 가지. 따라서 오류를 발견한 경우 조용히 실패할 수 있습니다. 이것이 의미하는 바는 오류를 발견했고 사용자가 제공한 잘못된 값을 다른 값으로 대체한다는 것입니다. 실제로는 별로 좋은 생각이 아닙니다. 그건 나쁜 생각이에요. 갑자기 사용자가 자신이 뭔가를 입력했다고 생각하고 모든 것이 훌륭하다고 생각하기 때문에 프로그램이 이를 수락하지만 출력으로 기대했던 것과는 거리가 먼 이상한 값을 얻습니다. 따라서 사용자의 값을 다른 것으로 바꾸는 것은 실제로 좋은 생각이 아닙니다.

문맥에서-- 이것은 함수의 문맥에 있는 것입니다. 함수의 맥락에서 우리는 또 무엇을 할 수 있나요? 예를 들어, 실패한 함수가 있다면 짝수의 제곱근을 구하려고 한다고 가정해 보겠습니다. 그리고 사용자가 당신에게... 죄송합니다. 당신은 양수의 제곱근을 찾으려고 한다고 가정해 보겠습니다. 그리고 사용자가 당신에게 음수를 준다고 가정해 봅시다. 음, 사용자가 음수를 제공하면 함수는 오류 값을 반환할 수 있습니다. 즉, 입력된 숫자가 0보다 작으면 0을 반환하거나 마이너스 1 또는 마이너스 100을 반환합니다. 반환할 값을 선택하기만 하면 됩니다. 이는 일부 오류 값을 나타냅니다.

이것은 실제로 좋은 생각도 아닙니다. 나중에 프로그램에서 이 기능을 사용하는 경우 지금 확인해야 하기 때문입니다. 그리고 확인은 이 함수의 반환값이 -1 또는 -100이면 이렇게 하라는 것입니다. 그렇지 않으면 이렇게 합니다. 따라서 이제 항상 이 오류 값을 확인해야 하기 때문에 코드가 복잡해집니다. 코드가 정말 지저분해집니다.

우리가 할 수 있는 또 다른 일은 오류 상태를 알리는 것입니다. 따라서 이것이 예외가 있는 프로그램에서 제어 흐름을 만드는 방법입니다. 따라서 Python에서 오류 조건 신호를 보내는 것은 자체 예외를 발생시키는 것을 의미합니다. 지금까지 우리는 프로그램이 충돌하는 것을 보았습니다. 이는 예외가 발생한 다음 이를 처리한다는 의미입니다. 하지만 이 마지막 경우에는 자신만의 예외가 발생합니다. 나중에 코드에서 해당 예외를 사용하는 방법입니다. 따라서 Python에서는 이 raise 키워드를 사용하여 자신만의 예외를 발생시킨 다음 예외를 발생시킵니다. 그런 다음 "사용자가 음수를 입력했습니다"와 같은 일종의 설명이 있습니다.

많은 경우 값 오류가 발생합니다. 따라서 숫자가 0보다 작으면 값 오류가 발생합니다. 이는 뭔가 잘못된 것입니다. 키워드, 오류 이름, 그리고 일종의 설명 문자열입니다.

그럼 예외를 발생시키는 방법의 예를 살펴보겠습니다. 여기에 get ratios라는 함수가 있습니다. L1과 L2라는 두 개의 목록을 사용합니다. 그리고 L1의 각 요소를 L2의 각 요소로 나눈 비율을 포함하는 새 목록을 생성할 것입니다. 여기에 for 루프가 있습니다. 범위 길이가 L1인 인덱스의 경우. 그래서 저는 L1의 모든 단일 요소를 살펴보겠습니다. 나는 여기에서 시험해 볼 예정이다. 이 라인을 만들어 보려고 합니다. 그래서 저는 이 줄이 나에게 오류를 줄 수도 있다고 생각합니다. 그래서 나는 그것을 try 블록에 넣을 것입니다. 내가 얻게 될 오류는 0 나누기 오류입니다. 요소와 L2가 0이면 어떻게 됩니까?

그리고 L2의 요소가 0이면 숫자가 아닌 부동 소수점을 추가하겠습니다. 따라서 NAN은 문자열이므로 부동 소수점으로 변환할 수 있으며 이는 숫자가 아님을 나타냅니다. 그러면 숫자가 아닌 숫자로 목록을 계속 채울 수 있습니다. 요소와 L2가 0인 경우. 그렇지 않고 0 나누기 오류는 없지만 다른 종류의 오류가 있는 경우 자체 오류를 발생시키겠습니다. 그리고 다른 종류의 오류에 대해서는 값 오류를 발생시키세요. "get ratios가 잘못된 인수로 호출되었습니다."라는 뜻입니다. 그래서 여기서는 모든 오류를 하나의 값 오류로 통합합니다. 그래서 나중에 내 프로그램에서 이 값 오류를 잡아서 뭔가를 할 수 있습니다.

다음은 예외의 또 다른 예입니다. 그럼 우리에게 수업 목록이 주어졌다고 가정해 봅시다. 우리는 목록의 목록을 가지고 있습니다. 학생의 이름, 이름, 성, 수업 성적이 있는 곳입니다. 그래서 현재 우리 학생은 2명입니다. 그리고 제가 하고 싶은 것은 여기에 동일한 내용, 동일한 입력이 포함된 새 목록을 만드는 것입니다. 하지만 저는 추가 값을 추가합니다. 각 학생의 목록 끝에 추가 값을 추가합니다. 이는 모든 성적의 평균입니다. 아니면 그 학생들의 모든... 그래, 그 학생들의 모든 성적.

그럼 코드를 살펴보겠습니다. 이것은 클래스 목록을 취하는 함수입니다. 여기 전체 목록이 있습니다. 그 안에 처음에는 비어 있는 새 목록을 만들고 있습니다. 그런 다음 클래스 목록의 모든 요소를 ​​살펴보겠습니다. 여기서 첫 번째 목록이 될 요소를 0에 추가하겠습니다. 따라서 이름과 성이 됩니다. 1의 요소는 등급입니다. 그리고 마지막으로 추가할 것은 함수 호출입니다. 모든 등급인 요소 1로 호출되는 함수 호출이 제 함수 호출입니다. 우리는 세 가지 다른 함수 호출을 보게 될 것입니다. 이것이 첫 번째입니다. 단순히 성적의 합을 성적의 길이로 나눕니다. 이 학생들이 책임감을 갖고 모든 시험을 치렀다면 문제가 없습니다. 성적의 길이는 0보다 큰 값이 될 것이기 때문입니다. 하지만 수업에 어떤 시험에도 나타나지 않은 학생이 있다면 어떻게 될까요? 그렇다면 우리는 그들의 테스트에 대한 기록이 없습니다. 성적이나 그런 기록은 없습니다. 그래서 그들은 빈 목록을 갖게 될 것입니다. 따라서 데이터에 대해 평균 함수를 실행하면 실제로 0 나누기 오류가 발생하게 됩니다. 왜냐하면 우리가 성적의 길이로 나누려고 하기 때문에 0이 되기 때문입니다.

그래서 우리가 뭘 할 수 있지? 여기에는 두 가지 옵션이 있습니다. 하나는 오류에 플래그를 지정하고 메시지를 인쇄할 수 있다는 것입니다. 여기에 새로운 평균 함수, 개선된 함수가 있습니다. 이전 함수와 정확히 동일한 행을 수행하려고 시도하는 것입니다. 그리고 0 나누기 오류를 잡을 것입니다. 그리고 그것을 발견하면 이 경고를 인쇄할 것입니다. 그리고 이를 실행하면 "경고, 성적 데이터 없음"이라는 메시지가 표시됩니다. 괜찮습니다. 그리고 우리는 여기서 성적에 대해 "없음"을 얻게 될 것입니다. 따라서 다른 모든 사람의 성적은 올바르게 계산되었으며 마지막 성적에서는 없음을 받았습니다.

왜냐하면 우리가 이 Except 문을 입력했을 때 이것이 함수라면 함수는 무언가를 반환한다는 것을 기억하기 때문입니다. 이 특정문의 이 함수는 아무것도 반환하지 않았습니다. 따라서 없음을 반환합니다. 따라서 이 특정 기능에 대한 평균의 경우 관련 등급이 없는 이 사람의 평균은 "없음"이 됩니다. 그리고 네, 기본적으로 제가 말한 것이 바로 그것입니다. 이것이 우리의 첫 번째 옵션입니다. 오류에 플래그를 지정하고 메시지를 인쇄하는 것입니다.

다른 옵션은 실제로 정책을 변경하는 것입니다. 따라서 여기가 데이터를 일종의 기본값으로 바꾸는 곳입니다. 그리고 이와 같은 작업을 수행하는 경우 해당 내용이 함수 내부에 문서화되어야 합니다. 따라서 함수에 대한 독스트링을 작성할 때 목록이 비어 있으면 0이 될 것이라고 말할 것입니다. 따라서 이것은 이전과 완전히 똑같습니다. 0 나누기 오류를 제외하고 시도한 결과가 있습니다. 또한 성적 데이터가 아닌 경고를 인쇄합니다. 그런 다음 0을 반환합니다. 따라서 여전히 오류에 플래그를 지정하고 이제 "없음" 대신 0을 얻습니다. 왜냐하면 공백으로 두는 것이 아니라 여기서 0.0을 반환했기 때문입니다.

괜찮은. 그래서 그것은 예외입니다. 오늘 우리가 마지막으로 이야기할 것은 어설션이라고 불리는 것들입니다. 그리고 주장은 방어 프로그래밍의 좋은 예입니다. 일반적으로 함수 시작 부분에 주장 문이 있습니다. 또는 기능이 끝날 때. 그리고 Assert 문은 계산에 대한 가정이 함수가 기대하는 것과 정확히 일치하는지 확인하는 데 사용됩니다. 따라서 0보다 큰 정수를 취해야 한다고 말하는 함수가 있는 경우, Assert 문은 함수가 0보다 큰 정수를 취한다고 주장합니다.

여기에 예가 있습니다. 이것은 이전에 본 것과 동일한 평균 함수입니다. 여기서는 예외를 사용하는 대신 Assert 문을 사용하겠습니다. 그리고 우리가 바로 앞에 놓을 주장 문. 기능 시작 부분에서 죄송합니다. 그리고 핵심 단어는 주장입니다. Assert의 다음 부분은 함수가 기대하는 것입니다. 따라서 우리는 성적의 길이가 0이 아닐 것이라고 예상합니다. 따라서 0보다 커야 합니다. 그리고 여기에 주장이 성립하지 않을 경우 무엇을 인쇄할지 나타내는 문자열이 있습니다.

따라서 함수를 실행하고 비어 있는 목록을 제공하면 이는 false가 되어 Assert가 false가 되고 성적 데이터가 없는 Assertion 오류를 인쇄하게 됩니다. 주장이 거짓이면 함수는 계속되지 않습니다. 바로 거기에서 멈 춥니 다. 왜 이런 식으로 동작합니까? 글쎄요, 단언은 함수의 전제 조건과 사후 조건이 예상한 것과 정확히 일치하는지 확인하는 데 유용합니다. 따라서 어설션이 거짓이 되자마자 함수는 즉시 종료됩니다. 이는 프로그램이 잘못된 값을 전파하는 것을 방지하므로 유용합니다.

따라서 예를 들어 함수를 입력할 때 전제 조건이 참이 아닌 경우 이는 프로그램에 문제가 있다는 의미입니다. 그리고 프로그램은 바로 거기서 멈출 것입니다. 따라서 프로그램 전체에 잘못된 값을 전파하고 예상치 못한 출력을 얻은 다음 이 잘못된 값을 제공한 함수를 다시 추적해야 하는 대신 이러한 잘못된 값을 얻게 됩니다. 이 주장이 훨씬 더 일찍 거짓이라는 것을 알게 될 것입니다. 그러면 버그가 어디서 왔는지 알아내는 것이 훨씬 더 쉬울 것입니다. 그리고 그렇게 많은 단계를 추적할 필요도 없습니다.

그래서 이것이 기본적으로 제가 말한 것입니다. 버그가 소개되자마자 버그를 발견하고 싶어한다는 것입니다. 그리고 사용자가 잘못된 데이터 입력을 제공할 때 예외를 발생시키려는 경우에는 예외가 좋지만 어설션은 유형 및 기타(함수 입력 유형, 함수 입력에 대한 다른 조건)가 유지되고 있는지 확인하는 데 사용됩니다. 값이 전달될 때. 따라서 여기서 키워드는 데이터 구조의 불변성을 의미하는지 확인하는 것입니다. 그리고 그게 다야. 엄청난. 감사해요.