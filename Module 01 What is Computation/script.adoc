오늘 우리는 기본적인 행정 정보와 약간의 코스 정보를 살펴 보겠습니다. 그리고 나서, 계산이 무엇인지에 대해 조금 이야기해 보겠습니다. 모두가 같은 page에 있는지 확인하기 위해 컴퓨터가 무엇을 하는지 매우 높은 수준에서 논의할 것입니다.

그런 다음 Python의 기본을 살펴봅니다. Python으로 할 수 있는 수학적 연산에 대해 이야기 합니다. 그런 다음 Python 변수 유형에 대해 이야기 하겠습니다.

제가 소개 이메일에서 언급했듯이, 제가 강의 중에 이야기할 모든 슬라이드와 코드는 강의 전에 올라올 예정이므로, 다운로드하여 열어두실 것을 적극 권장합니다. 우리는 해당 슬라이드에서 사용할 수 있는 몇 가지 수업 중 연습을 진행할 것입니다. 그리고 그것은 재미 있습니다.

그리고 나중에 참고할 목적으로 코드에 대해 메모해 두는 것도 좋습니다. 사실이에요. 이것은 정말 빠르게 진행되는 과정이고 우리는 정말 빠르게 발전합니다. 우리는 귀하가 이 과정에서 성공할 수 있도록 돕고 싶습니다.

이 글을 쓰면서 나는 처음 프로그래밍을 시작했을 때 첫 번째 프로그래밍 과정을 마치는 데 무엇이 도움이 되었는지 생각하려고 했습니다. 그리고 이것은 정말 좋은 목록입니다. 첫 번째는 pset가 나오자마자 읽고, 용어가 나오는지 확인하고, pset이 나오자마자 읽고, 용어가 제대로 이해되었는지 확인하는 것이었습니다.

그러다가 강의를 하다가 갑자기 생각난 게 있어서 강사님이 말씀을 하시면 아, 그 단어를 pset에서 봤는데 그게 뭔지 몰랐어요. 글쎄요, 이제 그게 뭔지 알겠습니다. 오른쪽? 그러니 한번 읽어보세요. 시작할 필요가 없습니다.

프로그래밍이 처음이라면 핵심 단어는 연습이라고 생각합니다. 수학이나 독서와 같습니다. 더 많이 연습할수록 더 잘할 수 있습니다. 나는 이미 프로그래밍 방법을 알고 있기 때문에 내가 프로그램을 작성하는 것을 보면서 프로그래밍에 흡수되지는 않을 것입니다. 여러분, 연습해야 합니다.

강의 전에 코드를 다운로드하세요. 을 따라서. 내가 무엇을 입력하든 여러분은 입력할 수 있습니다. 그리고 내 생각에 가장 큰 문제 중 하나는 프로그래밍을 처음 접하는 사람이라면 컴퓨터가 고장날까 봐 두려워한다는 것입니다. 그리고 실제로 Anaconda를 실행하고 일부 명령을 입력하는 것만으로는 그렇게 할 수 없습니다.

따라서 몇 가지 내용을 입력하고 결과를 확인하는 것을 두려워하지 마십시오. 최악의 경우에는 컴퓨터를 다시 시작하면 됩니다. 응. 아마도 그게 가장 큰 문제일 겁니다. 강조했어야 했는데, 두려워하지 마세요.

좋아요. 따라서 이것은 제가 방금 설명한 대로 6.0001 또는 600 전체에 대한 거의 로드맵입니다. 이 과정에서 우리가 얻고자 하는 세 가지 중요한 것이 있습니다. 첫 번째는 개념에 대한 지식입니다. 이는 여러분이 듣게 될 모든 수업에 거의 적용됩니다.

수업은 강의를 통해 뭔가를 가르쳐 줄 것입니다. 시험은 당신이 얼마나 알고 있는지 테스트합니다. 프로그래밍 수업입니다. 우리가 당신에게 바라는 또 다른 것은 프로그래밍 기술입니다.

그리고 마지막으로, 이것이 이 수업을 정말 훌륭하게 만드는 이유는 바로 문제 해결 방법을 가르쳐준다는 점입니다. 그리고 우리는 psets를 통해 이를 수행합니다. 이것이 제가 이 과정의 로드맵이 실제로 보이는 방식이라고 생각합니다.

그리고 이 모든 것의 바탕에는 바로 연습이 있습니다. 몇 가지 내용을 입력하고 많은 코드를 작성해야 합니다. 그리고 내 생각에 당신은 이 과정에서 성공할 것 같아요.

좋아요. 그럼 이번 수업에서 우리가 배울 내용은 무엇인가요? 이번 수업에서 배울 내용은 기본적으로 세 가지 섹션으로 나눌 수 있을 것 같습니다. 첫 번째 것은 여기의 처음 두 항목과 관련이 있습니다. 실제로 프로그래밍 방법을 배우는 것입니다.

프로그래밍 방법을 배우는 것의 일부는 어떤 개체를 만들 것인지 알아내는 것입니다. 이에 대해서는 나중에 배우게 됩니다. 데이터 구조로 지식을 어떻게 표현합니까? 그것은 일종의 광범위한 용어입니다.

그리고 프로그램을 작성할 때 다음이 필요합니다. 프로그램은 단지 선형적이지 않습니다. 때로는 프로그램이 뛰어다니기도 합니다. 그들은 결정을 내립니다. 프로그램에는 몇 가지 제어 흐름이 있습니다. 두 번째 줄에 관한 내용은 다음과 같습니다.

이 코스의 두 번째 큰 부분은 좀 더 추상적이며, 좋은 코드, 좋은 스타일, 읽기 쉬운 코드를 작성하는 방법을 다룹니다. 코드를 작성할 때 대기업에 있으면서 다른 사람이 읽고 사용하게 되므로 다른 사람이 읽고 이해할 수 있어야 합니다.

이를 위해서는 잘 조직되고, 모듈식이며, 이해하기 쉬운 코드를 작성해야 합니다. 그뿐만 아니라, 여러분의 코드는 다른 사람들이 읽을 수 있을 뿐만 아니라, 내년에는 아마도 다른 과정을 수강하게 될 것이며 이 수업에서 작성한 문제 중 일부를 되돌아보고 싶을 것입니다.

코드를 다시 읽을 수 있기를 원합니다. 큰 혼란이라면 자신이 하고 있던 일을 이해하지 못하거나 다시 이해하지 못할 수도 있습니다. 그래서 읽기 쉬운 코드를 작성하고 코드를 정리하는 것도 큰 부분입니다.

그리고 마지막 섹션에서 다룰 것입니다. 처음 두 섹션은 실제로 Python 프로그래밍 및 컴퓨터 과학 입문의 프로그래밍의 일부입니다. 그리고 마지막 부분은 Python 프로그래밍 및 컴퓨터 과학 입문의 컴퓨터 과학 부분을 주로 다룹니다.

우리는 Python으로 프로그램을 작성하는 방법을 배운 후에 Python으로 프로그램을 어떻게 비교할 수 있는지에 대해 이야기할 것입니다. 한 프로그램이 다른 프로그램보다 낫다는 것을 어떻게 알 수 있나요?

한 프로그램이 다른 프로그램보다 더 효율적이라는 것을 어떻게 알 수 있나요? 한 알고리즘이 다른 알고리즘보다 낫다는 것을 어떻게 알 수 있나요? 이것이 우리가 강좌의 마지막 부분에서 이야기할 내용입니다.

좋아요. 이것이 코스의 관리 부분에 대한 전부입니다. 컴퓨터가 하는 일을 높은 수준에서 이야기하는 것부터 시작하겠습니다.

== 컴퓨터는 어떤 일을 하는가?

* 기본적으로:
    * 계산을 수행함: 1초에 수십 억 번의 계산을 수행
    * 결과를 저장: 수백 Tera byte의 저장 공간을 가짐
* 어떤 종류의 계산을 수행하는가?
    * 프로그래밍 언어에 미리 포함된(built-in) 계산
    * 프로그래머가 정의한 계산
* 컴퓨터는 이야기 하지 않은 것을 알지 못함

기본적으로 두 가지 일을 합니다. 하나, 계산을 수행합니다. 많은 계산을 수행합니다. 요즘 컴퓨터는 정말 정말 빠릅니다. 초당 10억 개의 계산을 수행하는 것도 그리 멀지 않을 것입니다. 이러한 계산을 수행하고 어딘가에 저장해야 합니다. 그쵸? 컴퓨터 메모리에 저장합니다.

따라서 컴퓨터도 결과를 기억해야 합니다. 그리고 요즘에는 수백 기가바이트의 저장 공간을 갖춘 컴퓨터를 찾는 것이 드문 일이 아닙니다. 컴퓨터가 수행하는 계산에는 두 가지 종류가 있습니다.

하나는 언어에 내장된 계산입니다. 이는 덧셈, 뺄셈, 곱셈 등과 같은 매우 낮은 수준의 계산 유형입니다.

그리고 이러한 기본 계산 유형을 갖춘 언어가 있으면 프로그래머로서 이러한 유형을 조합한 다음 자신만의 계산을 정의할 수 있습니다. 새로운 유형의 계산을 생성할 수 있습니다. 그리고 컴퓨터는 그 일도 수행할 수 있을 것입니다.

제 생각에 제가 강조하고 싶은 한 가지는 – 그리고 우리는 이 강의 전체 동안 이것에 대해 다시 다시 언급할 것입니다 – 사실 – 컴퓨터는 당신이 말하는 것만을 안다는 것입니다. 컴퓨터는 사용자가 지시한 대로만 수행합니다. 그것들은 마술적이지 않습니다. 그들은 마음이 없습니다.

그들은 정말, 정말 빠르게 계산을 수행하는 방법을 알고 있습니다. 하지만 어떤 계산을 해야 하는지 알려줘야 합니다. 컴퓨터는 아무것도 모릅니다. 좋아요. 원래 그렇습니다.

지식의 종류를 살펴보겠습니다. 첫 번째 유형의 지식은 선언적 지식이다. 그리고 그것은 사실의 진술과 같은 것입니다. 그리고 이것이 바로 내 이메일이 등장한 곳입니다. 아래까지 끝까지 읽으셨다면 추첨에 응모하셨을 겁니다.

=== Knowledge의 종류

* 선언적 knowledge(declarative knowledge)는 "사실의 상태"
* 명령적 knowlegde(imparative knowledge)는 "레시피" 또는 "how-to"
    * 경품에 응모
    * IDE(Integrated Development Environment)를 열고
    * 1에서 n 사이의 무작위 숫자를 선택
    * 번호를 확인

그래서 오늘 강의의 사실 진술은 수업이 끝나기 전에 누군가가 상을 받을 것이라는 것입니다. 그리고 상품은 Google Cardboard였습니다. Google의 최첨단 가상 현실 안경. 그리고 바로 여기에 있어요. 응. 나는 약속을 지켰다.

그것은 사실에 대한 진술입니다. 그러니 내가 기계인 척 하세요. 좋아요? 나는 당신이 나에게 말하는 것 외에는 아무것도 모릅니다. 모르겠습니다. 나는 당신이 나에게 이런 말을 한 것을 알고 있습니다. 나는 마치, 알았어. 하지만 수업이 끝나기 전에 어떻게 Google Cardboard를 받을 수 있을까요?

이것이 바로 명령형 지식이 들어오는 곳입니다. 명령형 지식은 레시피, 방법 또는 단계의 순서입니다. 죄송합니다. 그것은 단지 나의 재미입니다. 따라서 일련의 단계는 필수적인 지식입니다.

내가 기계라면 수업 전에 누군가 Google Cardboard를 받을 수 있는 방법을 알려줘야 합니다. 이 단계를 따르면 기술적으로 결론에 도달하게 됩니다.

첫 번째 단계는 이미 완료한 것 같습니다. 가입하고 싶은 사람이 가입했습니다. 이제 IDE를 열겠습니다. 나는 기본적으로 기계가 되어 당신이 말한 단계를 따르고 있을 뿐입니다.

이 수업에서 사용하는 IDE는 Anaconda입니다. 그냥 맨 아래로 스크롤하고 있어요. 문제 세트 0에 설치하셨기를 바랍니다. IDE를 열었습니다. 다음 지침을 따르겠습니다. 첫 번째 응답자와 n번째 응답자 사이에서 임의의 숫자를 선택하겠습니다.

이제 실제로 Python을 사용하여 이 작업을 수행하겠습니다. 그리고 이것은 인생에서 얼마나 간단한 일인지 보여주는 예이기도 합니다. 컴퓨터나 프로그래밍을 사용하면 그렇게 할 수 있습니다. 내가 임의의 숫자를 선택하면 예를 들어 숫자 8을 좋아할 수 있기 때문에 편향될 수 있기 때문입니다.

임의의 숫자를 선택하기 위해 저는 가서 이렇게 말할 것입니다. 응답자 목록은 어디에 있나요? 15에 시작해요. 사실 16에 시작해요. 그게 저거든요. 우리는 16과 최종 인물 266 사이에서 임의의 숫자를 선택할 것입니다. 아, 방금 얻었습니다... 오. 좋아요.

좋아요. 여기서 바로 끊겠습니다. 271. 알았어. 16과 271. 완벽해요. 좋아요. 임의의 숫자를 선택하겠습니다. 내 IDE로 이동하겠습니다. 아직 이 작업을 수행하는 방법을 알 필요는 없지만 이 수업이 끝나면 알게 될 것입니다. 저는 그냥 Python을 사용하겠습니다.

난 그냥 나에게 난수를 주는 난수 패키지를 얻을 것입니다. 나는 무작위라고 말할 것입니다.randint. 16에서 272 사이에서 임의의 숫자를 선택하겠습니다.

[source, python]
----
import random
random.randint(16, 272)
----

좋아요. 75. 알았어. 엄청난. 저는 임의의 숫자를 선택했습니다. 그리고 응답자 시트에서 번호를 찾아보겠습니다. 전화번호는 또 뭐였지? 죄송합니다. 75. 알았어. 올라가자. 우리는 거기에 갈. 로렌 Z-O-V. 응. 멋진. 너 여기 있네.

좋아요. 괜찮네요. 그것은 제가 기계이면서 동시에 일상 생활에서 Python을 사용하여 강의하고 임의의 숫자를 찾는 예입니다. 가능하다면 Python을 사용해 보세요. 그리고 그것은 당신에게 연습을 제공합니다.

재미있었어요. 하지만 우리는 MIT에 있어요. 우리는 MIT 학생입니다. 그리고 MIT는 숫자를 좋아합니다. 다음은 선언적 지식과 명령형 지식의 차이를 보여주는 수치적 예입니다. 선언적 지식과 명령형 지식의 차이를 보여주는 수치적 예입니다.

선언적 지식의 예는 y 곱하기 y가 x와 같다는, 즉 숫자 x의 제곱이 y라는 것입니다. 그것은 단지 사실에 대한 진술일 뿐입니다. 그것은 사실입니다. 컴퓨터는 그걸로 무엇을 해야할지 모릅니다. 그들은 그 말을 어떻게 해야 할지 모릅니다. 하지만 컴퓨터는 레시피를 따르는 방법을 알고 있습니다.

=== Numeric 예제
* 숫자 x의 제곱근은 y. y * y = x와 같음
* 숫자 x의 제곱근을 구하는 방법
** g라는 추측으로 시작
** 만약 g * g가 x의 제곱근 조건을 만족하면, 계산을 멈추고 g가 답이라고 말함
** 아니면, g와 x/g의 평균으로 새로운 추측
** 새 추측을 사용하여 제곱근 조건을 만족할 때 까지 반복

[cols=4, options=header]
|===
|g|g * g|x / g|(g + x / g) / 2
|3|9|16 / 3|4.17
|4.17|17.36|3.387|4.0035
|4.0035|16.0277|3.997|4.000002
|===

여기 잘 알려진 알고리즘이 있습니다. 숫자 x의 제곱근을 찾기 위해 x가 원래 16이라고 가정해 보겠습니다. 컴퓨터가 이 알고리즘을 따르면 g, 즉 3이라는 추측으로 시작합니다. 우리는 16의 제곱근을 찾으려고 합니다. .

우리는 g 곱하기 g = 9를 계산할 것입니다. 그리고 우리는 g 곱하기 g가 x에 충분히 가까운지 물어볼 것입니다. 맞으면 멈추고 g가 답이라고 말하세요.

9가 16에 가까워지는 것은 별로 만족스럽지 않습니다. 그래서 저는 여기서 멈추지 않을 것입니다. 나는 계속 갈 것이다.

충분히 가깝지 않으면 g와 x를 g에 걸쳐 평균하여 새로운 추측을 할 것입니다. 여기서는 x 나누기 g 입니다. 그리고 그것은 저기 평균입니다.

그리고 새로운 평균은 나의 새로운 추측이 될 것입니다. 그리고 그것은 그것이 말하는 것입니다. 그런 다음 마지막 단계는 새로운 추측을 사용하여 프로세스를 반복하는 것입니다. 그런 다음 처음으로 돌아가서 전체 과정을 계속해서 반복합니다.

그리고 이것이 나머지 행이 하는 일입니다. 그리고 당신이 충분히 가까워졌다고 결정할 때까지 이 일을 계속합니다. 이전 수치 예에서 명령형 지식에 대해 본 것은 x의 제곱근을 찾는 방법에 대한 레시피였습니다. 레시피의 세 부분은 무엇이었나요?

하나는 간단한 일련의 단계였습니다. 네 단계가 있었습니다. 다른 하나는 제어의 흐름이라 우리가 결정을 내리는 부분이 있었어요. 우리는 충분히 가깝나요? 몇 가지 단계를 반복하는 부분도 있었습니다. 마지막에는 1, 2, 3단계를 반복한다고 말했습니다. 이것이 제어의 흐름입니다.

그리고 레시피의 마지막 부분은 멈추는 방법이었습니다. 계속해서 진행되는 프로그램을 원하지 않습니다. 또는 레시피의 경우 빵을 계속 굽고 싶지 않을 수도 있습니다. 어느 시점에서 멈추고 싶습니다. 빵 10개면 충분하지 않나요? 그래서 멈출 방법이 있어야합니다.

이전 예에서 멈추는 방법은 충분히 가깝다고 판단하는 것이었습니다. 충분히 가까운 것은 아마도 당신이 무엇을 선택하든 .01, .001 이내일 것입니다. 이 레시피는 알고리즘을 위해 존재합니다. 컴퓨터 과학에서는 알고리즘이 될 것입니다. 그리고 이번 수업에서 우리가 배울 내용은 바로 이것입니다.

우리는 컴퓨터를 다루고 있습니다. 그리고 우리는 실제로 컴퓨터 내부의 레시피를 캡처하고 싶습니다. 컴퓨터는 기계적인 프로세스입니다. 역사적으로 컴퓨터에는 두 가지 유형이 있었습니다. 원래는 fixed-program computer 라는 것이 있었습니다.

