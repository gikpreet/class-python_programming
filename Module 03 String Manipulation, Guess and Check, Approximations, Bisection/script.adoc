= Module 03: 문자열 조작, 추측 및 확인, 근사치, 이등분

좋습니다 여러분, 시작해 보겠습니다. 좋은 오후입니다. 그럼 이번이 6.0001과 600의 3번째 강의입니다. 늘 그렇듯이 슬라이드와 코드를 다운받아 따라오시기 바랍니다.

그럼 지난번에 우리가 한 일을 간단히 요약해 보겠습니다. 지난번에 우리는 문자열을 새로운 객체 유형, 즉 문자 시퀀스로 이야기했습니다. 그리고 조금 더 복잡한 프로그램을 작성할 수 있는 두 가지 새로운 개념을 도입했습니다.

그래서 우리는 if, elif, else라는 키워드를 사용하여 분기를 도입했습니다. 그리고 분기를 통해 우리는 프로그래머로서 프로그램에 결정을 내릴 수 있는 프로그램을 작성할 수 있었습니다. 그런 다음 두 가지 다른 종류의 루프인 while 루프와 for 루프를 소개했습니다. 그리고 이는 또한 우리 프로그램에 약간의 복잡성을 추가했습니다.

오늘은 문자열에 대해 조금 더 이야기해보겠습니다. 따라서 문자열과 문자열 개체에 대해 수행할 수 있는 몇 가지 작업을 더 살펴보겠습니다. 그런 다음 세 가지 다른 알고리즘인 추측 및 확인 알고리즘, 근사해 알고리즘, 이분법 알고리즘에 대해 이야기하겠습니다.

그럼 바로 들어가 보겠습니다. 먼저 문자열에 대해 조금 이야기하겠습니다. 그래서 문자열은 지난 강의에서 작성한 프로그램에서 보았듯이 대소문자를 구분하는 문자의 시퀀스로 생각했습니다. 그리고 문자열은 객체입니다. 그리고 문자열 개체에 대해 동일한지, 작은지, 큰지 테스트하는 등 이러한 모든 작업을 수행할 수 있습니다.

우리는 단지 두 개의 문자열을 연결하거나 이들에 대한 작은 테스트를 수행하는 것 이상의 일을 할 수 있다는 것이 밝혀졌습니다. 이제 함수나 프로시저에 대한 아이디어를 소개하기 시작하겠습니다. 그리고 다음 강의에서는 함수에 대해 더 자세히 알아보고 자신만의 함수를 작성하는 방법을 알아보겠습니다.

하지만 오늘은, 함수를 사용자를 위해 무언가를 수행하는 일종의 프로시저로 생각할 수 있습니다. 누군가 이미 이 글을 썼습니다. 그래서 우리가 살펴볼 첫 번째 기능은 꽤 인기 있는 기능입니다.

== STRINGS

* 대소문자가 구분되는 문자(characters)의 순서로 생각할 수 있음
* ==, >, < 등으로 비교할 수 있음
* `len()` 은 괄호안의 string의 길이를 알아내는데 사용하는 함수

[source, python]
----
s = "abc"
len(s) -> 3을 계산함
----

그리고 문자열에 적용하면 len이라는 이 함수가 문자열의 길이를 알려줍니다. 그러면 문자열에 몇 개의 문자가 있는지 알려줄 것입니다. 그리고 문자는 문자열에 몇 개의 문자가 있는지 알려주는 것입니다. 문자는 문자, 숫자, 특수 문자, 공백 등이 될 것입니다. 따라서 문자열에 몇 개의 문자가 있는지 계산할 것입니다.

따라서 문자열 s가 "abc"와 같다면 -- 문자열이 따옴표 안에 있다는 것을 기억하세요 -- 그러면 제가 이렇게 하면, 여기서 len s라는 표현식을 쓰면 표현식이기 때문에 값. 따라서 특정 값으로 평가됩니다. 그리고 정의에 따르면 문자열의 길이가 얼마인지 알려줄 것입니다. 길이는 3자입니다.

문자열에 대해 할 수 있는 또 다른 일은 문자열이 일련의 문자이기 때문에 특정 위치에 어떤 문자가 있는지 알고 싶을 수도 있다는 것입니다. 그래서 우리는 인덱싱이라는 멋진 단어를 사용하여 이 작업을 수행합니다. 그러나 문자열에 대한 인덱싱이 의미하는 바는 파이썬에게 찌르기 내부의 특정 위치 또는 특정 인덱스에 있는 문자를 알고 싶다고 말하는 것입니다.

== STRINGS

* 대 괄호(square brakets)을 사용하여 문자열을 indexing 하여 index/position에 해당하는 값을 가져옴

[source, python]
----
s = "abc"

s[0] -> "a"를 가져옴
s[1] -> "b"를 가져옴
s[2] -> "c"를 가져옴
s[3] -> 범위를 벗어난 index, error
s[-1] -> "c"를 가져옴
s[-2] -> "b"를 가져옴
s[-3] -> "a"를 가져옴
----

다시 한 번 이 문자열을 사용해 보겠습니다. s는 "abc"와 같습니다. 그리고 그것을 색인화해 봅시다. 따라서 컴퓨터 과학에서는 관례에 따라 0부터 시작합니다. 이 클래스에는 문제 세트 0이 있었습니다. 파이썬도 다르지 않습니다.

따라서 Python에서는 위치 0에서 인덱싱을 시작합니다. 또는 0에서 인덱싱을 시작합니다. 따라서 문자열의 첫 번째 문자는 위치 0 또는 인덱스 0에 있습니다. 문자열의 다음 문자는 인덱스 1에 있습니다. 그리고 문자열의 다음 문자는 인덱스 2에 있습니다.

Python에서는 음수를 사용하여 색인을 생성할 수도 있습니다. 예를 들어 음수 1로 문자열을 색인화하는 경우 이는 문자열의 마지막 문자를 원한다는 의미입니다. 따라서 문자열의 마지막 문자는 항상 음수 1 위치에 있고, 마지막에서 두 번째 문자는 음수 2에, 마지막에서 세 번째 문자는 음수 3에 있는 식입니다.

따라서 문자열에 대한 색인을 생성하는 방법은 여기 대괄호를 사용하는 것입니다. 그리고 이것이 표기법입니다. 따라서 위치 0이나 인덱스 0에 있는 문자를 원하면 인덱스하려는 문자열인 s라고 말합니다. 그런 다음 대괄호 안에 내가 원하는 인덱스를 말합니다.

따라서 인덱스 0의 s는 "a" 값이 됩니다. 인덱스 1의 s는 값 "b"가 될 것입니다. 이런 식으로 계속됩니다. 그리고 음수 인덱싱도 수행할 수 있습니다.

여기에 이것을 추가했습니다. 문자열의 한계를 넘어 문자열에 대한 색인을 생성하려고 한다면, 그렇게 해도 세상의 종말이 아니라는 것을 보여주기 위해 이것을 시도해 볼 수도 있습니다. s가 "abc"와 같고 위치 20에 s가 있는 경우, 예를 들어 분명히 내 문자열의 길이는 3일 뿐인데 위치 20에 있는 것은 무엇입니까?

[source, python]
----
s = "abc"
s[20]
----

오류가 발생합니다. 나는 이것을 Python으로 화난 텍스트라고 부릅니다. 하지만 실제로 주목해야 할 가장 관련성이 높은 것은 여기 마지막 두 줄입니다. 이는 어떤 라인에 문제가 있는지 알려줍니다. 따라서 위치 20에 문제가 있습니다. 그리고 여기 마지막 줄은 제가 실제로 어떤 오류를 갖고 있는지 알려줍니다. 이는 인덱스 오류입니다. 즉, 문자열에 문자가 세 개밖에 없기 때문에 문자열에서 너무 멀리까지 인덱스를 지정하려고 한다는 의미입니다.

그래서 내 문자열에서 단일 문자를 가져올 수 있다는 것이 좋습니다. 하지만 때로는 하위 문자열을 얻고 싶을 수도 있습니다. 따라서 첫 번째 문자에서 시작하여 문자열의 중간으로 들어가거나, 그 사이에 몇 개의 문자를 사용하거나, 문자열에서 다른 모든 문자 또는 이와 유사한 문자를 건너뛰고 싶습니다.

[source, python]
----
s = "abcdefgh"
s[3:6]      -> "def", s[3:6:1]과 같음
s[3:6:2]    -> "df"
s[::]       -> "abdcdfgh", s[0:len(s):1]과 같음
s[::-1]     -> "hgfedcba", s[-1:-(len(s) + 1):-1]과 같음
s[4:1:-2]   -> "ec"
----

따라서 문자열과 좀 더 복잡한 상호작용을 수행하려면 이를 슬라이싱, 문자열로 슬라이싱(slicing into string)이라고 부릅니다. 그리고 여기 있는 이 표기법은 조금 친숙해 보일 것입니다. 지난 강의에서 범위를 사용하여 수행했을 때 보았기 때문입니다.

우리는 시작, 중지, 단계를 가졌습니다. 표기법은 약간 달랐습니다. 범위 내에서 열림-닫기 괄호와 그 사이에 쉼표가 있었기 때문입니다. 하지만 그 점을 제외하면 이런 종류의 작업은 동일합니다.

시작은 이 문자열을 분할하려는 위치부터 0부터 시작하는 인덱스입니다. 중지는 중지 인덱스입니다. 그래서 당신은 정지 마이너스 1까지 올라가서 그 지수를 취하게 될 것입니다. 그런 다음 단계는 원하는 문자 수입니다.

이것이 전체 표기법입니다. 하지만 때로는 여기에 세 번째 종류의 숫자를 지정할 수 없는 경우도 있습니다. 따라서 두 개의 숫자만 제공하면 Python에 이는 시작과 중지를 나타냅니다. 기본적으로 단계는 1이 됩니다.

그리고 문자열을 사용하여 할 수 있는 다른 작업도 많이 있습니다. Python에서는 숫자를 생략하고 콜론만 남겨 둘 수 있습니다. 정의에 따르면, 슬라이싱을 쓴 사람이 결정한 방식에 따라 숫자를 생략하면 여기 있는 것과 동일하게 됩니다.

따라서 인덱싱과 마찬가지로 대괄호를 사용하여 슬라이스합니다. 지금을 제외하고는 두 개의 숫자를 제공할 수 있습니다. 따라서 이 문자열 s를 사용하여 문자열 s를 분할하면 인덱스 3에서 시작하여 인덱스 6까지 올라갑니다. 따라서 abcdefgh가 있으면 위치는 0, 1, 2, 3, 4, 5, 6입니다. 7.

그리고 당신은 단지 계산합니다. 그래서 s는 3에서 시작해서 6까지 가는데, 여기서 3이 시작될 것입니다. 그래서 그것은-- 죄송합니다 d가 나올 것입니다. 그리고 우리는 e를 취할 것입니다. 그리고 우리는 f를 취할 것입니다. 그리고 우리는 정지 마이너스 1까지 갈 것이므로 g를 취하지 않을 것입니다. 왜냐하면 이것은 위치 6이고 6 빼기 1까지 갈 것이기 때문입니다.

여기 다음은 3, 6, 2가 한 번씩 갑니다. 그래서 우리는 3에서 시작하고 다른 모든 것을 건너뛰므로 e가 아닌 d로 가고 f로 간 다음 중지합니다.

s를 수행하고 콜론만 제외하고 내부에 아무것도 없는 경우 s가 있고 아무 것도 없으며 콜론, 없음, 콜론, 없음이 표시됩니다. 따라서 start를 위한 것도, step을 위한 것도, step을 위한 것도 없습니다. 그리고 그것은 문자열 자체의 가치를 평가할 것입니다. 매 단계마다 진행되는 길이 s의 0과 같습니다.

이것은 실제로 유용할 수 있습니다. 자동으로 문자열을 반대로 바꿉니다. 따라서 여기에 있는 이 작은 선으로 문자열의 역수를 얻을 수 있습니다. 그리고 그것은 그것과 동일합니다. 따라서 마이너스 1은 끝에서 시작하여 모든 문자로 돌아가는 것을 나타냅니다. 그리고 이것은 조금 더 복잡하지만 그리 나쁘지는 않습니다.

따라서 문자열 조각을 작성하는 동안 어떤 작업이 수행되는지 확실하지 않은 경우 Spider에 입력하면 됩니다. 그리고 당신은 놀랄 수도 있습니다. 그렇지 않을 수도 있습니다. 하지만 이는 자신을 점검하고 무슨 일이 일어나고 있는지 이해하고 있는지 확인하는 좋은 방법입니다.

제가 언급하고 싶은 한 가지는 이 내용을 마음속에 간직해 두는 것이 좋습니다. 좀 더 복잡한 객체 유형에 대해 이야기하기 시작하면서 이 문제로 다시 돌아올 것입니다. 그러나 문자열은 변경할 수 없습니다. 그러니 이 수업을 진행하는 동안 이 단어를 마음속에 간직하세요.

== STRINGS
* string은 "immutable" - 변경될 수 없음

[source, python]
----
s = "hello"

s[0] = 'y'              -> error
s = 'y' + s[1:len(s)]   -> 가능함. s는 새 객체
----

이것이 의미하는 바는 실제 문자열 개체가 일단 생성되면 수정할 수 없다는 것입니다. 지금 당장은 아무 의미가 없을 수도 있습니다. 하지만 조금 그려 보겠습니다. 이 문자열이 있다고 가정해 보겠습니다. s는 hello와 같습니다.

기억하세요, 첫 번째 강의에서 우리는 이런 종류의 다이어그램을 그렸습니다. 이것이 내 기억이다. 나는 "안녕하세요"라는 개체를 가지고 있습니다. 그리고 이 객체 "hello"는 이 변수 s에 바인딩됩니다. 이제 이 변수 s를 사용하여 "hello" 개체에 액세스할 수 있습니다.

이제 여러분은 문자열을 인덱싱할 수 있으므로 0 위치의 s는 y와 같다고 말할 수 있을 것이라고 생각할 수도 있습니다. 그리고 그것은 단지 작은 h를 y로 바꿀 것이고, 나는 새로운 객체를 갖게 될 것입니다.

문자열은 불변입니다. 즉, Python에서는 실제로 이렇게 하는 것이 허용되지 않습니다. 그리고 그렇게 하려고 하면 오류가 발생합니다. 변수 s가 문자열 YE-L-L-O를 가리키도록 하려면 s가 Y-E-L-L-O와 같다고 말할 수 있습니다.

또는 이와 같은 문자열 작업을 수행할 수도 있습니다. 그리고 이것은 y를 가져와 문자열 s, 즉 위치 1부터 시작하는 모든 요소인 e, l, l, o에 연결합니다. 그래서 Y-E-L-L-O가 됩니다.

이제 내부적으로, 제가 이 줄을 작성할 때 일어나는 일은 Python이 "좋아, 나는 이 원래 객체 "hello"와의 유대를 끊을 것이다라고 말하는 것입니다. 내 문자열 변수 s를 새 개체 "yello"에 바인딩하겠습니다. 그리고 이 또 다른 오래된 객체는 아직도 메모리 어딘가에 남아 있습니다. 하지만 제가 여기서 만든 것은 완전히 다른 개체입니다.

다시 말하지만, 지금 당장은 아무 의미가 없을 수도 있지만, 문자열은 변경할 수 없다는 점을 마음 속에 간직해 두세요.

그래서 제가 다음으로 이야기하고 싶은 것은 for 루프에 대한 약간의 요약입니다. 그리고 문자열을 다룰 때 매우 훌륭하고 읽기 쉬운 코드를 작성하기 위해 for 루프를 매우 쉽게 적용하는 방법을 살펴보겠습니다.

따라서 for 루프에는 루프 변수가 있다는 것을 기억하십시오. 내 루프 변수는 이 특별한 경우에 이 var입니다. 당신이 원하는 것은 무엇이든 될 수 있습니다. 그리고 이 변수는 이 특별한 경우에 0, 1, 2, 3, 4라는 일련의 숫자를 반복합니다.

따라서 루프를 처음 통과할 때 var의 값은 0입니다. 루프에서 표현식을 수행합니다. 완료되자마자 var는 값 1을 취합니다. 루프의 모든 표현식을 수행합니다. 그런 다음 var는 값 2를 취하여 0, 1, 2까지 계속 수행합니다. 그리고 마지막으로 var는 3과 같습니다.

그리고 사용자 정의 값에서 시작하여 다른 값으로 끝나고 특정 숫자를 건너뛰기 위해 범위를 사용자 정의할 수 있다고 말한 것을 기억하십시오.

지금까지 우리는 일련의 숫자에 대해서만 for 루프를 사용해 왔습니다. 그러나 실제로 for 루프는 그보다 훨씬 더 강력합니다. 이를 사용하여 숫자뿐만 아니라 문자열까지 모든 값 시퀀스를 반복할 수 있습니다.

여기에 두 개의 코드가 있습니다. 이것과 이 코드가 여기에 있습니다. 이 두 코드는 모두 동일한 작업을 수행합니다. 나에게, 아마도 당신에게는 이것이 첫눈에 이것보다 훨씬 더 읽기 쉬워 보입니다.

[source, python]
----
 s = "abcdefgh"

for index in range(len(s)):
    if s[index] == 'i' or s[index] == 'u':
        print("There is an i or u")

for char in s:
    if char == 'i' or char == 'u':
        print("There is an i or u")
----

여기서 키워드와 변수만 사용하여 이 글을 읽으면 마치 깨진 영어처럼 들릴 것입니다. 하지만 당신은 내가 말하려는 것을 해독할 수 있을 것입니다. 문자열 s의 char에 대해 char이 "i"와 같거나 char이 "u"와 같으면 "There is an i 또는 a u"를 인쇄합니다.

이상하게 들리겠지만, 내가 여기서 무엇을 하려고 했는지 아마 알 수 있을 것입니다. 반면에 여기에서는 내가 무엇을 하고 있는지 말하기가 좀 더 복잡합니다. 좀 생각을 해보셔야 할 것 같아요

이 숫자 범위의 일부 인덱스에 대해 0에서 문자열 s의 길이까지, s가 인덱스 위치에서 "i"이거나 위치 인덱스에서 s가 "u"인 경우 인쇄, "i 또는 u가 있습니다. ." 이 두 코드는 모두 문자열 s를 통과합니다. 그리고 i나 u인 문자를 만나면 여기에 이 문자열을 인쇄할 것입니다.

하지만 이 아래쪽 것은 훨씬 더 파이썬적(pythonic)입니다. Python 커뮤니티에서 만든 실제 단어입니다. 그리고 정말 예뻐보이죠? 이 코드가 무엇을 해야 하는지 알 수 있습니다. 반면에 이것은 해독하기가 조금 더 어렵습니다.

이것은 일련의 문자에 대한 for 루프의 일종의 예시입니다. 따라서 char은 여전히 루프 변수가 될 것입니다. 그리고 루프 변수는 숫자 집합을 반복하는 대신 s의 모든 문자를 직접 반복합니다. 그리고 char는 캐릭터가 될 것입니다. 문자가 될 거예요.

여기 좀 더 복잡한 예가 있습니다. 나는 몇 년 전에 이 코드를 작성했습니다. 그리고 로봇 치어리더를 만들려는 시도였습니다. 동기가 필요했기 때문입니다. 그리고 어젯밤에 "로봇 치어리더"를 검색했는데 실망하지 않았습니다. 이 GIF를 만들었습니다. 꽤 멋져 보입니다. 그리고 그들은 내 아이디어를 훔친 것 같습니다. 하지만 괜찮습니다.

그럼 이 코드가 어떤 역할을 하는지 살펴보겠습니다. 나는 그것을 실행할 것입니다. 제가 실행해서 살펴보겠습니다. 좋아요, "응원하겠습니다! 단어를 입력하세요."라고 출력됩니다.

[source, python]
----
an_letters = "aefhilmnorsxAEFHILMNORSX"

word = input("I will cheer for you! Enter a word:")
times = int(input("Enthuiasm level (1:10): "))

i = 0
while i < len(word):
    char = word[i]
    if char in an_letters:
        print("Give me an " + char + "! " + char)
    else:
        print("Give me a " + char + " ! " + char)
    i += 1

print("What does that spell?")
for i in range(times):
    print(word, "!!!")
----

저는 로봇을 좋아해서 "ROBOTS"라고 넣겠습니다. 나는 로봇에 대해 얼마나 열정적인가? 6을 가정해 봅시다. 이것이 인쇄할 내용은 -- 치어리더입니다. 그렇죠? "나에게 r, r을 줘." "오, 오 주세요." "나에게 b, b를 줘" 등등.

그 철자는 무엇입니까? ROBOTS." 그리고 6번 인쇄할 것입니다. 저는 10명 중 6명이 로봇에 열광하기 때문입니다. 이것이 바로 이 코드가 해야 할 일입니다. 그리고 지금까지 배운 내용을 사용하여 작성할 수 있습니다.

이제 조금 살펴보겠습니다. 그리고 문자에 대한 for 루프를 사용하여 이 코드를 변환하는 것이 얼마나 쉬운지 보여 드리겠습니다. 지금은 사용자에게 단어와 숫자 입력을 요청합니다.

그리고 나서 이런 일을 합니다. 맞죠? 첫째, while 루프를 사용합니다. 둘째, 인덱싱을 사용합니다. 그리고 인덱싱을 사용한다는 사실에서 알 수 있는 점은 여기 단어에 대괄호를 사용한다는 것입니다.

그리고 분명히 while 루프를 사용하고 있습니다. 그리고 먼저 카운터를 생성하고 초기화해야 합니다. 그런 다음 여기 아래에 있는 while 루프 내에서 이를 증가시킵니다. 기억하신다면, 이것이 바로 while 루프에 대해 우리가 해야 할 일입니다.

따라서 0에서 시작하여 기본적으로 인덱스 i는 0, 1, 2, 3 4와 동일하며 사용자가 입력한 단어의 끝까지 계속 진행됩니다. , 이 경우에는 "ROBOTS"입니다. 해당 위치에 캐릭터가 위치하게 됩니다. i 위치에 있는 단어는 문자가 될 것입니다.

여기 이 줄은 치어리더의 이해를 돕기 위한 것입니다. 단지 an을 사용하는 것이 의미가 있는 글자를 관리하기 위한 것 뿐이죠? 그러니 나에게 b를 줘, 나에게 b를 줘. 그러니 나에게 b를 주는 것은 말이 안 되는 거죠, 그렇죠? 그래서 그것은 단지 그것을 처리하는 것입니다.

그리고 저는 이것을 키워드에서 문자(예를 들어 로봇의 문자 r)가 문자 안에 있는지 확인하는 데 사용하고 있습니다. 그리고 제가 여기서 정의한 문자는 문자 앞에 an을 붙이는 것이 의미가 있는 모든 문자입니다. 예를 들어 여기 오른쪽에 r을 입력해 주세요.

따라서 문자 앞에 an을 사용하는 것이 타당하다면 해당 문자를 사용하고 그렇지 않은 경우에는 a만 사용하세요. 그리고 다 마친 후에는 "그게 무슨 뜻이에요?"라고 묻습니다. 그런 다음 그것은 여러 번 반복되어 단어와 느낌표를 인쇄하는 for 루프일 뿐입니다.

따라서 이 코드를 다시 작성했거나 원래 for 루프를 사용하여 작성했다면 조금 더 직관적이었을 것입니다. 따라서 여기 이 부분, while 루프와 인덱싱 및 원래 카운터 생성을 통해 이를 제거할 수 있습니다.

[source, python]
----
an_letters = "aefhilmnorsxAEFHILMNORSX"

word = input("I will cheer for you! Enter a word:")
times = int(input("Enthuiasm level (1:10): "))

for char in word:
    if char in an_letters:
        print("Give me an " + char + "! " + char)
    else:
        print("Give me a  " + char + "! " + char)

print("What does that spell?")
for i in range(times):
    print(word, "!!!")
----

그리고 우리는 이것을 문자로 표현하면 이것으로 바꿀 수 있습니다. 저는 원래 char를 사용하고 있으므로 다시 char을 루프 변수로 사용할 수 있습니다. 간단히 말해, 단어 자체를 반복하겠습니다.

이제 여기에서 이런 혼란을 겪는 대신, 내 단어의 모든 문자에 대해 이 모든 작업을 여기서 수행하라는 한 줄의 내용이 있습니다. 그래서 그것은 동일하게 유지됩니다. 그런 다음 더 이상 while 루프를 사용하지 않기 때문에 카운터 변수를 증가시킬 필요조차 없습니다. 저는 단지 for 루프를 사용하고 있습니다.

따라서 코드는 - 삭제하세요 - 단어의 문자에 대한 것입니다. 그런 다음 삭제하십시오. 그리고 그것은 똑같은 일을 합니다. 그리고 훨씬 더 읽기 쉽습니다.

이것이 이 과정을 시작할 때 우리가 사용했던 도구 상자였습니다. 우리는 2와 1/2 정도 강의를 하고 있는 것 같아요. 이것들이 우리가 거기에 추가한 것들입니다. 우리는 정수, 부동 소수점, 부울을 알고 있습니다. 우리는 약간의 문자열 조작, 수학 연산을 알고 있습니다. 우리는 최근에 좀 더 흥미로운 프로그램을 작성하기 위해 이러한 조건문과 분기를 추가했습니다.

이제 흥미롭고 더 복잡한 프로그램을 추가하기 위한 루프, for 및 while 루프가 있습니다. 따라서 이번 강의의 두 번째 부분에서는 세 가지 다른 알고리즘을 살펴보겠습니다. 이것이 바로 이 수업의 컴퓨터 과학 부분인 "Python을 사용한 컴퓨터 과학 및 프로그래밍 입문"입니다.

알고리즘이라는 단어에 겁을 내지 마십시오. 그다지 복잡하지 않습니다. 당신은 그들에 대해 조금 생각해야합니다. 그리고 당신은 그것들을 얻을 수 있을 것입니다.

그래서 우리는 세제곱근을 찾는 한 가지 문제를 해결하는 맥락에서 세 가지 알고리즘을 살펴보겠습니다. 첫 번째 알고리즘은 추측과 확인이며, 그 다음에는 근사 알고리즘과 이분법 검색을 살펴보겠습니다.

그래서 첫 번째는 추측과 확인 방법이다. 여러분은 수학이나 고등학교 때 이런 일을 했을 수도 있습니다. 추측 및 확인 방법은 때로는 철저한 열거라고도 합니다. 그러면 그 이유를 알게 될 것입니다.

문제가 주어지면 숫자의 세제곱근을 구하고 해의 시작 값을 추측할 수 있다고 가정해 보겠습니다. 추측 및 확인 방법은 솔루션이 올바른지 확인할 수 있는 경우에 효과적입니다.

그래서 여러분의 추측이 원래 0이라면, 0이 제가 세제곱근을 찾으려고 하는 모든 것의 세제곱과 같다고 말할 수 있습니까? 그럼 8의 세제곱근을 찾으려고 한다면 0의 세제곱은 8과 같나요? 아니요. 따라서 해결책이 올바르지 않습니다.

정확하지 않다면 다른 값을 추측해 보세요. 해결책을 찾거나 가능한 모든 값을 추측하여 검색 공간을 모두 소진할 때까지 체계적으로 수행하세요.

여기에 숫자의 세제곱근을 찾는 매우 간단한 추측 및 확인 코드가 있습니다. 그래서 저는 8의 세제곱근을 찾으려고 노력하고 있습니다. 그래서 제 큐브는 8입니다. 저는 0부터 시작하겠다고 말하는 for 루프를 가질 것입니다. 그리고 끝까지 갈 것입니다. 까지--

그래서 저는 0부터 시작해서 8까지 가겠습니다. 이 숫자들 각각에 대해 제가 추측한 3의 거듭제곱은 8의 세제곱과 같을까요? 그렇다면 저는 이 메시지를 인쇄하겠습니다.

[source, python]
----
cube = 8
for guess in range(cube + 1):
    if guess**3 == cube:
        print("Cube root of", cube, "is", guess)
----

매우 간단하지만 이 코드는 사용자 친화적이지 않습니다. 그렇죠? 사용자가 9의 세제곱근을 찾으려고 하면 어떤 결과도 얻지 못할 것입니다. 왜냐하면 추측이 완벽한 큐브가 아닌 경우에는 아무 것도 인쇄하지 않기 때문입니다. 또는 큐브가 완벽한 큐브가 아닌 경우.

따라서 코드를 약간 수정하여 두 가지 추가 기능을 추가할 수 있습니다. 첫 번째는 음수 큐브를 다룰 수 있다는 점인데, 꽤 멋지네요.

[source, python]
----
cube = 9
for guess in range(abs(cube) + 1):
    if guess**3 >= abs(cube):
        break
if guess**3 == abs(cube):
    print(cube, 'is not a perfect cube')
else:
    if cube < 0:
        guess = -guess
    print('Cube root of' + str(cube) + ' is ' + str(guess))
----

두 번째는 사용자에게 세제곱수가 완전 세제곱수가 아니라면 이 큐브는 완전 세제곱수가 아니라고 말할 것입니다. 따라서 우리는 조용히 실패하지 않을 것입니다. 왜냐하면 사용자는 자신의 입력에 대해 일종의 피드백을 가지기 때문입니다.

이제 이 코드를 단계별로 살펴보겠습니다. 먼저 이전과 마찬가지로 for 루프가 있습니다. 이 경우에는 0부터 8까지 진행하겠습니다. 우리는 음수의 세제곱근을 찾고 싶기 때문에 절대값을 사용하고 있습니다.

우리가 가장 먼저 하는 일은 여기서 확인하는 것입니다. 3의 거듭제곱에 대한 추측이 세제곱과 같은지 추측하는 대신, 그보다 크거나 같은지 확인하려고 하는데, 다음과 같은 이유로 그렇게 하려고 합니다.

예를 들어, 8의 세제곱근과 9의 세제곱근을 찾으려고 한다면 이것은 8이고 이것은 9입니다. 이 코드는 무엇을 하게 될까요? 먼저 0을 추측할 것입니다. 0의 세제곱은 8보다 크거나 같지 않습니다. 1의 세제곱은 8보다 크거나 같지 않습니다.

2의 세제곱은 8보다 크거나 같습니다. 따라서 여기서 2를 추측한 후에는 반복을 그만둡니다. 효과가 있는 숫자를 찾았기 때문입니다. 그리고 계속해서 찾을 필요도 없습니다. 이 숫자 8의 세제곱근을 찾으면 나머지 3, 4, 5, 6, 7, 8을 계속 검색할 필요가 없습니다.

9의 세제곱근을 구하려고 할 때도 같은 생각입니다. 0부터 시작하겠습니다. 0의 3제곱은 9보다 작습니다. 1의 3제곱은 9보다 작습니다. 2의 제곱은 9보다 작습니다. 3의 거듭제곱은 9보다 작습니다.

3의 3제곱에 도달하면 9보다 커집니다. 따라서 이 코드는 세제곱근의 합당한 수를 초과하는 숫자를 선택하면 다음과 같은 숫자를 선택했음을 알려줍니다. 우리의 세제곱근, 우리 세제곱근, 우리 세제곱근의 합당한 수를 넘어서는 숫자가 나오면 멈춰야 합니다.

다시 말하지만 계속 검색하는 것은 의미가 없기 때문입니다. 왜냐하면 3의 3승이 이미 9보다 크다면 4의 3승도 9보다 커지기 때문입니다. 따라서 여기서 중단하면 우리가 찾으려는 큐브에 따라 2가 될 수도 있고 3이 될 수도 있습니다.

그리고 3의 거듭제곱에 대한 추측이 큐브와 같지 않다면 분명히 큐브는 완벽한 큐브가 아닙니다. 이것이 바로 이 경우입니다. 우리가 9의 세제곱근을 보고 있다면 이 부분은 단지 양수로 만들어야 할지 음수로 만들어야 할지를 살펴보는 것뿐입니다. 따라서 원래 세제곱이 0보다 작았다면 분명히 음수의 세제곱근은 음수가 될 것이고, 그렇지 않은 경우에는 단지 우리의 추측일 뿐입니다.

== APPROXIMATE SOLUTIONS

* "충분한(Good Enough)" 해결
* 추측으로 시작해서 작은 값을 사용해 증가
* 만약 `| guess^3^ - cube | >= epsilon` 이면 작은 epsilon을 사용해 추측을 유지

* 증가치를 줄이면   -> 프로그램이 느려짐
* epsilon을 키우면  -> 정확도가 떨어짐

이것이 바로 추측 및 확인 방법이며, 세제곱근을 추측하기 위한 좀 더 기능이 풍부한 프로그램입니다. 하지만 이는 perfect cube의 세제곱근만을 알려줄 뿐 실제로 다른 어떤 정보도 제공하지 않습니다.

그래서 때때로 여러분은 "9가 완벽한 세제곱이 아니더라도 상관없어. 그냥 충분히 가까운 답을 줘"라고 말하고 싶을 수도 있습니다. 그래서 이것이 대략적인 해법이 들어오는 곳입니다. 그래서 이것이 우리가 충분한 해법을 갖고 있는 곳입니다.

그래서 그렇게 하기 위해 우리는 추측으로 시작한 다음 그 추측을 작은 값만큼 증가시키겠습니다. 0부터 시작하여 0.001씩 증가하기 시작하고 거기에서 위쪽으로 이동합니다. 그리고 어느 시점에서는 충분히 좋은 해결책을 찾을 수도 있습니다.

이 프로그램에서 우리는 충분히 가깝지 않은 한 계속 추측할 것입니다. 그리고 프로그램의 이 엡실론 값에 의해 충분히 가까운 값이 제공될 것입니다. 따라서 추측의 세제곱에서 세제곱을 뺀 값, 즉 실제 답에서 얼마나 멀리 떨어져 있는지가 엡실론보다 큰 한 계속 추측해 보세요. 해가 충분하지 않기 때문입니다.

그러나 이것이 엡실론보다 작으면 우리는 충분히 좋은 해에 도달한 것입니다. 따라서 대략적인 솔루션에 대해 주목해야 할 두 가지 사항이 있습니다. 따라서 단계 크기가 정말 작을 경우 더 정확한 답변을 얻을 수 있습니다. 0.0001씩 증가시키면 정말 좋은 근사값을 얻을 수 있지만 프로그램 속도가 훨씬 느려집니다.

엡실론과 같은 종류의 아이디어로 엡실론을 변경할 수 있습니다. 엡실론을 더 큰 엡실론으로 변경하면 정확도가 떨어지지만 솔루션에 훨씬 더 빨리 도달하게 됩니다. 여기에 세제곱근의 대략적인 해를 구하는 코드가 있습니다.

위협적으로 보일 수도 있지만 이 코드의 거의 절반은 단지 변수를 초기화하는 것입니다. 그래서 우리는 초기화 중입니다. 이것이 우리가 큐브 루트를 찾고자 하는 큐브입니다. 우리는 이것의 엡실론을 선택합니다. 우리는 0의 추측으로 시작합니다. 0.0001의 증분으로 시작합니다. 그리고 재미삼아 답을 찾는 데 필요한 추측 횟수를 추적해 보겠습니다.

[source, python]
----
cube = 27
epsilon = 0.01
guess = 0.0
increment = 0.0001
num_guesses = 0

while abs(guess**3 - cube) >= epsilon and guess <= cube:
    guess += increment
    num_guesses += 1

print('num_guesses = ', num_guesses)

if abs(guess**3 - cube) >= epsilon:
    print('Failed on cobe root of', cube)
else:
    print(guess, 'us close to the cube root of', cube)
----

이는 이전의 추측 및 확인과 유사합니다. 비슷하지 않습니다. 뭐 이 부분은 앞서 추측하고 확인했던 부분과 비슷하네요. 그럼 우리는 3에서 세제곱을 뺀 값을 추측해 보겠습니다. 그렇죠? 그렇다면 실제 답변과는 얼마나 멀리 떨어져 있습니까?

그리고 그것이 충분하지 않다면, 즉 우리가 여전히 엡실론보다 크거나 같다면 계속 추측해 보아야 한다고 말할 것입니다. 그래서 우리는 충분히 좋은 추측에 도달할 때까지, 즉 엡실론보다 작아질 때까지 값을 계속 추측하는 이 루프에 갇힐 것입니다.

그리고 우리가 추측을 계속하는 방법은 바로 여기 이 줄을 사용하는 것입니다. 즉, 내 추측을 증가시켜 증가시키고 증가는 매우 작은 값이 된다는 것입니다. 말 되네?
그래서 나는 그 작은 값만큼 내 추측을 계속 증가시킬 것입니다. 계속하기 전에 코드를 실행하겠습니다. 그리고 우리는 그것에 대한 작은 문제를 발견하게 될 것입니다.

그래서 27로 실행해보겠습니다. 완벽해요. 300번의 추측이 필요했어요. 하지만 2.99999는 27의 세제곱근에 가깝습니다. 여기서 이 숫자(8120601)의 세제곱근을 찾을 수 있습니다. 그리고 200,000번의 추측이 필요했지만 200.99999, 즉 201이 그 큰 숫자의 세제곱근에 가깝다는 것을 알아냈습니다.

[source, python]
----
cube = 27
cube = 8120601
epsilon = 0.01
guess = 0.0
increment = 0.0001
num_guesses = 0

while abs(guess**3 - cube) >= epsilon and guess <= cube:
    guess += increment
    num_guesses += 1

print('num_guesses = ', num_guesses)

if abs(guess**3 - cube) >= epsilon:
    print('Failed on cobe root of', cube)
else:
    print(guess, 'us close to the cube root of', cube)
----

나는 이것을 했어야 했다. 이건 경품이 될 거예요, 여러분. 죄송합니다. 그러면 우리는... 10,000의 큐브를 시도하고 싶다고 가정해 보겠습니다. 따라서 10,000은 완벽한 큐브가 아닙니다. 이제 코드를 실행할 수 있습니다. 그리고 8,120,601로 나는 이미 답을 얻었습니다. 그런데 10,000이면 아직 답이 안나오죠?

[source, python]
----
cube = 27
cube = 8120601
cube = 10000
epsilon = 0.01
guess = 0.0
increment = 0.0001
num_guesses = 0

while abs(guess**3 - cube) >= epsilon and guess <= cube:
    guess += increment
    num_guesses += 1

print('num_guesses = ', num_guesses)

if abs(guess**3 - cube) >= epsilon:
    print('Failed on cobe root of', cube)
else:
    print(guess, 'us close to the cube root of', cube)
----

그래서 뭔가 문제가 있을 수도 있겠다는 생각이 듭니다. 그래서 내 코드를 중지하겠습니다. 무한 루프에 빠진 것 같아서 그냥 컨트롤 C를 눌렀습니다. 그리고 사실 나는 그랬다. 그래서 결국 일어난 일은 여기서 이 문제입니다.

그래서 뭔가를 그려보겠습니다. 코드에 따르면 저는 0부터 시작해서 이렇게 추측값을 증가시키겠습니다. 조금씩 증가할 때마다 나는 새로운 추측을 하게 될 것입니다. 나는 그 추측을 3의 거듭제곱으로 가져갈 것입니다. 나는 세제곱을 뺄 것이고, 내가 엡실론보다 작은지 알아낼 것입니다.

이것이 제가 있고 싶은 엡실론입니다. 여기 이 작은 부분이 있습니다. 그래서 모든 새로운 추측이 있을 때마다 저는 어쩌면... 그래서 제가 있고 싶은 곳은 여기 이 작은 경계 안에 있습니다. 새로운 추측이 있을 때마다 나는 여기에 있을 수도 있다.
다음 추측으로는 내가 여기에 있을지도 모른다. 내가 또 다른 추측을 하게 되면 나는 여기에 있을지도 모른다. 그래서 나는 엡실론 안에 있는 것에 가까워지고 있습니다. 하지만 다음 추측에서는 엡실론을 뛰어넘어 너무 큰 추측을 하게 될 수도 있습니다.

따라서 이 예에서 숫자가 선택된 방식 때문에 이를 설명하기 위해 0.01의 증분을 사용하여 10,000의 세제곱과 0.1의 엡실론을 구하는 방법으로 제가 이 모든 계산을 수행할 때 , 저는 이 완벽한 종류의 엡실론 차이를 건너뛰겠습니다.

먼저, 저는 너무 작아질 것입니다. 그러면 나는 너무 커지게 될 것입니다. 그리고 내가 너무 커지거나 엡실론에서 너무 멀어지면 내가 계속 추측하는 것은 엡실론에서 훨씬 더 멀어질 것입니다. 그리고 나는 내 대답에 도달하지 않을 것입니다.

이것이 바로 이 코드에서 무한 루프에 도달한 이유입니다. 이 코드에서 제가 하는 일은 추측한 입방체에서 입방체를 뺀 값이 엡실론보다 작은지 확인하는 것뿐입니다. 여기서 해야 할 유일한 일은 여기에 다음과 같은 작은 절을 추가하는 것입니다. 아, 그런데, 내가 큐브보다 작은지도 확인하세요. 왜냐하면 이것은 우리가 첫 번째 프로그램에서 했던 것과 똑같기 때문입니다. 0, 1, 2, 3, 4, 5, 6, 7, 8을 확인할 때, 8의 세제곱근을 구하려고 할 때. 8시가 됐으니 그만 두겠습니다. 그리고 여기에서도 마찬가지입니다.

그래서 저는 방금 다음과 같은 작은 절을 추가했습니다. 음, 제가 엡실론보다 크거나 같고 여전히 실제 큐브보다 작더라도 계속 검색하세요. 하지만 일단 큐브에 도달하면 검색을 중지하세요.

그리고 10,000개를 사용하면 제가 실제로 찾지 못했다는 것을 알 수 있습니다. 이것이 바로 여기 이 부분이 하는 일입니다. 해당 특정 매개변수를 사용하여 큐브 루트를 찾지 못했다는 메시지가 표시됩니다.




마지막으로 살펴볼 것은 이분법 검색이다. 이것을 설명하려면 한 명의 자원봉사자가 필요합니다. 그리고 너는 학급 전체가 보는 앞에서 나와 함께 게임을 하게 될 것이다. 그리고 상품이있을 것입니다. 손이 간다. 파란색 셔츠를 입고 바로 거기에 있어요. 시원한.

그래서 상은 다시 한 번 이것이 될 것입니다. 나는 이런 구글 안경이 수백만 개는 없다고 약속합니다. 나는 또한 Google에서 일하지 않습니다. 방금 우연히 커플을 얻었어요.

그래서 게임은 이렇습니다. 저는 여러분에게 0에서 100 사이의 정수 중 하나를 선택하라고 요청할 것입니다. 그리고 그것을 추측해 볼 것입니다. 그리고 당신은 나를 힘들게 해야 합니다. 그리고 내가 10번의 추측으로도 추측할 수 없도록 너무 어렵게 만들어야 합니다.

그리고 당신이 그렇게 할 수 있다면, 제가 10번의 추측 이내에 그것을 추측할 수 없다면 당신은 이것을 얻습니다. 그리고 나는 우리가 진행하면서 내가 하는 일을 그려볼 것입니다. 그럼 전화번호는 있어요? 예?

청중: 네.

아나 벨: 완벽해요. 그거 지우도록 할게요. 사실, 나는 그것을 계속 사용할 것이기 때문에 아마도 그것을 보관했어야 했습니다. 0부터 100까지의 숫자가 있습니다. 당신의 숫자는 50인가요?

청중: 아니요.

ANA BELL: 50은 제 추측이었어요. 그래서 한 가지 추측을 해봤습니다. 당신의 숫자는 50보다 높습니까, 낮습니까?

청중: 더 높습니다.

ANA BELL: 더 높아요. 귀하의 번호는... 제가 다음으로 추측한 것은 75가 될 것입니다. 그리고 제가 75라고 추측하는 이유는... 귀하의 이름이 무엇입니까?

청중: 소피.

아나벨: ?

청중: 소피.

아나벨: 소피. 소피는 50은 너무 낮다고 말했습니다. 그래서 나는 그것이 50보다 작을 수 없다는 것을 즉시 압니다. 그래서 나는 이미 숫자의 절반을 제거했습니다. 그럼 내 다음 추측은 75입니다. 당신의 숫자는 75인가요? 당신의 숫자는 더 낮나요, 아니면 더 높나요?

청중: 더 높습니다.

ANABELL: 더 높기 때문에 여기서는 이 절반을 제거하겠습니다. 당신 번호는-- 그럼 75에서 100사이군요. 오 이런, 당신이 나를 곤란하게 만들고 있군요. 그게 뭐야?

청중: 87.

ANA BELL: 87, 감사합니다. 87 인가요?

청중: 아니요.

ANA BELL: 더 높나요, 더 낮나요?

청중: 더 낮습니다.

아나 벨: 더 낮습니다. 그래서 더 낮기 때문에 그 절반을 제거하겠습니다. 당신의 전화번호는 81번인가요? 더 높나요, 더 낮나요?

청중: 더 낮습니다.

ANA BELL: 그래서 그녀는 더 낮게, 그래서 그 절반을 제거하겠다고 말했습니다. 당신의 전화번호는 78번인가요? 아, 그거 정말 힘들어요. 78, 그렇군요. 더 높나요, 더 낮나요?

청중: 더 낮습니다.

ANA BELL: 당신 번호는 76번인가요?

청중: 네.

아나 벨: 예. 좋아, 완벽해. 76이 숫자였어. 그래서 나는 얼마나 많은 추측을 했습니까? 하나, 둘, 셋, 넷, 다섯, 여섯... 여섯 가지 추측을 했습니다. 그래서 10 미만으로 잡았습니다. 그런데 그거 알아요? 게임이 조작되었습니다. 어쨌든 내가 게임을 조작했기 때문에 당신은 상을 받게 됩니다. 여기요. 받으세요.

청중: 감사합니다.

아나 벨: 감사합니다. 이분법 검색에서 제가 한 일은 모든 추측에서 검색 공간의 절반을 제거한 것입니다. 음, 높거나 낮기 때문에 다른 검색 공간에 있을 수는 없다고 하더군요. 그렇죠? 대략적인 해법을 구하거나 이 경우 추측 및 확인을 한다면 소피에게 당신의 숫자는 0, 1, 2, 3, 4 등입니까?라고 묻게 될 것입니다.

따라서 추측과 확인을 사용했다면 숫자를 알아내는 데 76번의 추측이 필요했을 것입니다. 반면에 제가 방금 수행한 이분법 검색에서는 6번밖에 걸리지 않았습니다. 멋지지 않나요?

즉, 실제로 공간이 클수록 검색해야 하며 이등분 검색 방법인 이등분 검색을 사용하는 것이 더 좋습니다. 그래서 이것이 기본적으로 제가 여기서 설명하고 있는 것입니다. 그래서 우리는 원래의 검색 공간을 갖게 되었습니다. 우리는 추측을 중간에 선택하고 추측의 절반을 제거할 것입니다. 그런 다음 남은 간격을 살펴보고 추측의 절반을 제거하는 등의 작업을 계속합니다.

[source, python]
----
cube = 27
epsilon = 0.01
num_glasses = 0
low = 0
high = cube
guess = (high + low) / 2.0

while abs(guess**3 - cube) >= epsilon:
    if guess**3 < cube:
        low = guess
    else:
        high = guess
    guess = (high + low) / 2.0
    num_guesses += 1
print('num_guess =', num_guesses)
print(guess, 'is close to the cobe root of', cube)
----

그러면 이것이 이분법 검색을 위한 코드입니다. 또한 위협적으로 보이지만 그렇게 나쁘지는 않습니다. 그래서 우리는 여기에서 많은 것들을 초기화하고 있습니다. 우리가 초기화하는 가장 중요한 몇 가지 사항은 무엇보다도 높은 경계와 낮은 경계입니다.

그래서 추측 게임에서는 낮은 경계가 0이고 높은 경계가 100이었습니다. 큐브 루트를 보면 낮은 경계는 0이 되고 높은 경계는 바로 내 큐브가 될 것입니다. 왜냐하면 3제곱의 추측은 세제곱보다 클 수 없기 때문입니다. 그런 다음 추측 게임에서 했던 것과 동일한 절차를 수행할 것입니다. 즉, 추측이 중간이 되도록 할 것입니다. 그래서 이 추측 게임에서 저는 선택을 해야 했습니다. 사이에 4개의 숫자가 있다면 더 높아야 할까요, 아니면 더 낮아져야 할까요?

음, 우리가 이분법 검색을 할 때 여기서는 그것에 대해 신경 쓰지 않습니다. 우리는 소수점 숫자를 원하기 때문에 부동 소수점 나눗셈을 할 것입니다. 그래서 나는 낮은 경계와 높은 경계를 가지고 있습니다. 그리고 나는 중간 지점을 알아 냈습니다.

그러면 여기에 while 루프가 있습니다. while 루프는 근사치 방법과 유사합니다. 여기서 충분히 좋은 손님이 없는 한 이것은 엡실론보다 크거나 같은 것으로 묘사됩니다. 제 추측이 충분하지 않은 한 계속 추측해 볼게요. 이것이 while 루프가 말하는 것입니다.

따라서 3 빼기 세제곱의 추측이 충분하지 않다면 계속 추측하세요. 그리고 제가 계속 추측하는 방식은 바로 이 부분입니다. 여기에서는 제 추측이 너무 낮았다고 말합니다. 따라서 내 추측이 너무 낮다면 낮은 경계를 추측으로 설정하세요. 나보다 훨씬 낮은 다른 숫자들에는 전혀 관심이 없기 때문이다.

따라서 추측이 되도록 낮은 값을 설정하십시오. 그것이 바로 그 라인이 하는 일입니다. 그렇지 않으면 내 추측이 너무 높았습니다. 이것이 바로 다른 사람이 하는 일입니다. 따라서 추측한 값보다 높은 값을 설정하십시오. 왜냐하면 나는 내 추측보다 높은 숫자에는 관심이 없기 때문입니다.

이러한 새 경계가 있으면 새 경계 지점 사이의 중간에서 또 다른 추측을 합니다. 그래서 본질적으로 저는 추측할 때마다 간격을 절반으로 줄입니다. 이것이 바로 while 루프가 하는 일입니다. 그런 다음 나머지 부분을 인쇄합니다.

따라서 검색 공간이 원래 N이라는 점에 주목하세요. 각 추측에서 이를 절반으로 줄입니다. 따라서 첫 번째 추측에서는 이를 2로 나누고, 두 번째 추측에서는 이를 4로 나누는 식으로 진행됩니다. 따라서 k번째 추측인 N/2k, k번째 추측에 도달할 때 그것이 우리가 관심 있는 실제 답이라고 가정해 보겠습니다. 그 짧은 간격에는 값이 하나만 있습니다. 이것이 바로 우리가 원하는 대답입니다.

그러면 2의 k는 N과 같습니다. 그렇다면 우리는 몇 번이나 추측했을까요? k는 N의 로그 베이스 2와 같습니다. 따라서 우리가 100의 추측 게임을 할 때 내 끝은 100이었습니다. 100의 로그 베이스 2는 6입니다.

그래서 사실, 7번의 추측 안에 맞추지 못하면 당신도 이겼을 것이라고 말할 수도 있었습니다. 그래서 게임이 조작된 거죠. 따라서 추측, 주목, N의 관점에서 선형적으로 수렴하는 대신 로그 밑수 N의 순서로 수렴합니다. 이것이 바로 이것이 강력한 이유입니다.

마지막으로 언급하고 싶은 것은 제가 보여드린 코드가 포지티브 큐브에서만 작동한다는 것입니다. 그리고 그 이유는 다음과 같습니다. 그래서 저는 0과 1을 가지고 있습니다. 제가 0.5의 세제곱근을 찾으려고 한다고 가정해 보겠습니다.

처음에 경계를 정했을 때 나의 최저치는 이것이고, 나의 최고치는 이것이었습니다. 그런데 0.5의 세제곱근은 무엇입니까? 이 경계 안에 있습니까, 아니면 이 경계 밖에 있습니까?

청중: 경계 밖에 있습니다.

ANA BELL: 밖에서 들었어요. 0.7 정도 되는 것 같아요. 그래서 여기 있습니다. 따라서 이 특정 코드를 사용하면 해당 숫자 사이의 간격을 절반으로 줄이겠지만 결코 답을 얻을 수는 없습니다. 실제 세제곱근 0.5, 즉 1보다 작은 숫자는 해당 경계 외부에 있게 되기 때문입니다.

따라서 프로그램에 약간의 변경을 가하면 문제가 해결됩니다. 그리고 그것은 코드에 있습니다. 제가 넣지는 않았지만 아주 작은 변화, 작은 if 문입니다. 그래서 그게 다입니다. 알겠습니다. 감사합니다.